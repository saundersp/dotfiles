From 8d4e38d766e25f26708b8c901b49c4997afbab44 Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Tue, 17 May 2022 22:13:47 +0200
Subject: [PATCH 01/12] Changed font to Hasklug Nerd Font Mono

---
 config.def.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/config.def.h b/config.def.h
index 2cd740a..0111bd5 100644
--- a/config.def.h
+++ b/config.def.h
@@ -5,7 +5,7 @@
  *
  * font: see http://freedesktop.org/software/fontconfig/fontconfig-user.html
  */
-static char *font = "Liberation Mono:pixelsize=12:antialias=true:autohint=true";
+static char *font = "Hasklug Nerd Font Mono:pixelsize=14:antialias=true:autohint=true";
 static int borderpx = 2;
 
 /*
-- 
2.44.0


From 96c063ede6130085de27cb62c735922fe67d9da9 Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Tue, 17 May 2022 22:14:12 +0200
Subject: [PATCH 02/12] Added boxdraw patch

---
 Makefile       |   3 +-
 boxdraw.c      | 194 ++++++++++++++++++++++++++++++++++++++++++++
 boxdraw_data.h | 214 +++++++++++++++++++++++++++++++++++++++++++++++++
 config.def.h   |  12 +++
 st.c           |   3 +
 st.h           |  10 +++
 x.c            |  21 +++--
 7 files changed, 451 insertions(+), 6 deletions(-)
 create mode 100644 boxdraw.c
 create mode 100644 boxdraw_data.h

diff --git a/Makefile b/Makefile
index 15db421..a64b4c2 100644
--- a/Makefile
+++ b/Makefile
@@ -4,7 +4,7 @@
 
 include config.mk
 
-SRC = st.c x.c
+SRC = st.c x.c boxdraw.c
 OBJ = $(SRC:.c=.o)
 
 all: st
@@ -17,6 +17,7 @@ config.h:
 
 st.o: config.h st.h win.h
 x.o: arg.h config.h st.h win.h
+boxdraw.o: config.h st.h boxdraw_data.h
 
 $(OBJ): config.h config.mk
 
diff --git a/boxdraw.c b/boxdraw.c
new file mode 100644
index 0000000..28a92d0
--- /dev/null
+++ b/boxdraw.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2018 Avi Halachmi (:avih) avihpit@yahoo.com https://github.com/avih
+ * MIT/X Consortium License
+ */
+
+#include <X11/Xft/Xft.h>
+#include "st.h"
+#include "boxdraw_data.h"
+
+/* Rounded non-negative integers division of n / d  */
+#define DIV(n, d) (((n) + (d) / 2) / (d))
+
+static Display *xdpy;
+static Colormap xcmap;
+static XftDraw *xd;
+static Visual *xvis;
+
+static void drawbox(int, int, int, int, XftColor *, XftColor *, ushort);
+static void drawboxlines(int, int, int, int, XftColor *, ushort);
+
+/* public API */
+
+void
+boxdraw_xinit(Display *dpy, Colormap cmap, XftDraw *draw, Visual *vis)
+{
+	xdpy = dpy; xcmap = cmap; xd = draw, xvis = vis;
+}
+
+int
+isboxdraw(Rune u)
+{
+	Rune block = u & ~0xff;
+	return (boxdraw && block == 0x2500 && boxdata[(uint8_t)u]) ||
+	       (boxdraw_braille && block == 0x2800);
+}
+
+/* the "index" is actually the entire shape data encoded as ushort */
+ushort
+boxdrawindex(const Glyph *g)
+{
+	if (boxdraw_braille && (g->u & ~0xff) == 0x2800)
+		return BRL | (uint8_t)g->u;
+	if (boxdraw_bold && (g->mode & ATTR_BOLD))
+		return BDB | boxdata[(uint8_t)g->u];
+	return boxdata[(uint8_t)g->u];
+}
+
+void
+drawboxes(int x, int y, int cw, int ch, XftColor *fg, XftColor *bg,
+          const XftGlyphFontSpec *specs, int len)
+{
+	for ( ; len-- > 0; x += cw, specs++)
+		drawbox(x, y, cw, ch, fg, bg, (ushort)specs->glyph);
+}
+
+/* implementation */
+
+void
+drawbox(int x, int y, int w, int h, XftColor *fg, XftColor *bg, ushort bd)
+{
+	ushort cat = bd & ~(BDB | 0xff);  /* mask out bold and data */
+	if (bd & (BDL | BDA)) {
+		/* lines (light/double/heavy/arcs) */
+		drawboxlines(x, y, w, h, fg, bd);
+
+	} else if (cat == BBD) {
+		/* lower (8-X)/8 block */
+		int d = DIV((uint8_t)bd * h, 8);
+		XftDrawRect(xd, fg, x, y + d, w, h - d);
+
+	} else if (cat == BBU) {
+		/* upper X/8 block */
+		XftDrawRect(xd, fg, x, y, w, DIV((uint8_t)bd * h, 8));
+
+	} else if (cat == BBL) {
+		/* left X/8 block */
+		XftDrawRect(xd, fg, x, y, DIV((uint8_t)bd * w, 8), h);
+
+	} else if (cat == BBR) {
+		/* right (8-X)/8 block */
+		int d = DIV((uint8_t)bd * w, 8);
+		XftDrawRect(xd, fg, x + d, y, w - d, h);
+
+	} else if (cat == BBQ) {
+		/* Quadrants */
+		int w2 = DIV(w, 2), h2 = DIV(h, 2);
+		if (bd & TL)
+			XftDrawRect(xd, fg, x, y, w2, h2);
+		if (bd & TR)
+			XftDrawRect(xd, fg, x + w2, y, w - w2, h2);
+		if (bd & BL)
+			XftDrawRect(xd, fg, x, y + h2, w2, h - h2);
+		if (bd & BR)
+			XftDrawRect(xd, fg, x + w2, y + h2, w - w2, h - h2);
+
+	} else if (bd & BBS) {
+		/* Shades - data is 1/2/3 for 25%/50%/75% alpha, respectively */
+		int d = (uint8_t)bd;
+		XftColor xfc;
+		XRenderColor xrc = { .alpha = 0xffff };
+
+		xrc.red = DIV(fg->color.red * d + bg->color.red * (4 - d), 4);
+		xrc.green = DIV(fg->color.green * d + bg->color.green * (4 - d), 4);
+		xrc.blue = DIV(fg->color.blue * d + bg->color.blue * (4 - d), 4);
+
+		XftColorAllocValue(xdpy, xvis, xcmap, &xrc, &xfc);
+		XftDrawRect(xd, &xfc, x, y, w, h);
+		XftColorFree(xdpy, xvis, xcmap, &xfc);
+
+	} else if (cat == BRL) {
+		/* braille, each data bit corresponds to one dot at 2x4 grid */
+		int w1 = DIV(w, 2);
+		int h1 = DIV(h, 4), h2 = DIV(h, 2), h3 = DIV(3 * h, 4);
+
+		if (bd & 1)   XftDrawRect(xd, fg, x, y, w1, h1);
+		if (bd & 2)   XftDrawRect(xd, fg, x, y + h1, w1, h2 - h1);
+		if (bd & 4)   XftDrawRect(xd, fg, x, y + h2, w1, h3 - h2);
+		if (bd & 8)   XftDrawRect(xd, fg, x + w1, y, w - w1, h1);
+		if (bd & 16)  XftDrawRect(xd, fg, x + w1, y + h1, w - w1, h2 - h1);
+		if (bd & 32)  XftDrawRect(xd, fg, x + w1, y + h2, w - w1, h3 - h2);
+		if (bd & 64)  XftDrawRect(xd, fg, x, y + h3, w1, h - h3);
+		if (bd & 128) XftDrawRect(xd, fg, x + w1, y + h3, w - w1, h - h3);
+
+	}
+}
+
+void
+drawboxlines(int x, int y, int w, int h, XftColor *fg, ushort bd)
+{
+	/* s: stem thickness. width/8 roughly matches underscore thickness. */
+	/* We draw bold as 1.5 * normal-stem and at least 1px thicker.      */
+	/* doubles draw at least 3px, even when w or h < 3. bold needs 6px. */
+	int mwh = MIN(w, h);
+	int base_s = MAX(1, DIV(mwh, 8));
+	int bold = (bd & BDB) && mwh >= 6;  /* possibly ignore boldness */
+	int s = bold ? MAX(base_s + 1, DIV(3 * base_s, 2)) : base_s;
+	int w2 = DIV(w - s, 2), h2 = DIV(h - s, 2);
+	/* the s-by-s square (x + w2, y + h2, s, s) is the center texel.    */
+	/* The base length (per direction till edge) includes this square.  */
+
+	int light = bd & (LL | LU | LR | LD);
+	int double_ = bd & (DL | DU | DR | DD);
+
+	if (light) {
+		/* d: additional (negative) length to not-draw the center   */
+		/* texel - at arcs and avoid drawing inside (some) doubles  */
+		int arc = bd & BDA;
+		int multi_light = light & (light - 1);
+		int multi_double = double_ & (double_ - 1);
+		/* light crosses double only at DH+LV, DV+LH (ref. shapes)  */
+		int d = arc || (multi_double && !multi_light) ? -s : 0;
+
+		if (bd & LL)
+			XftDrawRect(xd, fg, x, y + h2, w2 + s + d, s);
+		if (bd & LU)
+			XftDrawRect(xd, fg, x + w2, y, s, h2 + s + d);
+		if (bd & LR)
+			XftDrawRect(xd, fg, x + w2 - d, y + h2, w - w2 + d, s);
+		if (bd & LD)
+			XftDrawRect(xd, fg, x + w2, y + h2 - d, s, h - h2 + d);
+	}
+
+	/* double lines - also align with light to form heavy when combined */
+	if (double_) {
+		/*
+		* going clockwise, for each double-ray: p is additional length
+		* to the single-ray nearer to the previous direction, and n to
+		* the next. p and n adjust from the base length to lengths
+		* which consider other doubles - shorter to avoid intersections
+		* (p, n), or longer to draw the far-corner texel (n).
+		*/
+		int dl = bd & DL, du = bd & DU, dr = bd & DR, dd = bd & DD;
+		if (dl) {
+			int p = dd ? -s : 0, n = du ? -s : dd ? s : 0;
+			XftDrawRect(xd, fg, x, y + h2 + s, w2 + s + p, s);
+			XftDrawRect(xd, fg, x, y + h2 - s, w2 + s + n, s);
+		}
+		if (du) {
+			int p = dl ? -s : 0, n = dr ? -s : dl ? s : 0;
+			XftDrawRect(xd, fg, x + w2 - s, y, s, h2 + s + p);
+			XftDrawRect(xd, fg, x + w2 + s, y, s, h2 + s + n);
+		}
+		if (dr) {
+			int p = du ? -s : 0, n = dd ? -s : du ? s : 0;
+			XftDrawRect(xd, fg, x + w2 - p, y + h2 - s, w - w2 + p, s);
+			XftDrawRect(xd, fg, x + w2 - n, y + h2 + s, w - w2 + n, s);
+		}
+		if (dd) {
+			int p = dr ? -s : 0, n = dl ? -s : dr ? s : 0;
+			XftDrawRect(xd, fg, x + w2 + s, y + h2 - p, s, h - h2 + p);
+			XftDrawRect(xd, fg, x + w2 - s, y + h2 - n, s, h - h2 + n);
+		}
+	}
+}
diff --git a/boxdraw_data.h b/boxdraw_data.h
new file mode 100644
index 0000000..7890500
--- /dev/null
+++ b/boxdraw_data.h
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2018 Avi Halachmi (:avih) avihpit@yahoo.com https://github.com/avih
+ * MIT/X Consortium License
+ */
+
+/*
+ * U+25XX codepoints data
+ *
+ * References:
+ *   http://www.unicode.org/charts/PDF/U2500.pdf
+ *   http://www.unicode.org/charts/PDF/U2580.pdf
+ *
+ * Test page:
+ *   https://github.com/GNOME/vte/blob/master/doc/boxes.txt
+ */
+
+/* Each shape is encoded as 16-bits. Higher bits are category, lower are data */
+/* Categories (mutually exclusive except BDB): */
+/* For convenience, BDL/BDA/BBS/BDB are 1 bit each, the rest are enums */
+#define BDL (1<<8)   /* Box Draw Lines (light/double/heavy) */
+#define BDA (1<<9)   /* Box Draw Arc (light) */
+
+#define BBD (1<<10)  /* Box Block Down (lower) X/8 */
+#define BBL (2<<10)  /* Box Block Left X/8 */
+#define BBU (3<<10)  /* Box Block Upper X/8 */
+#define BBR (4<<10)  /* Box Block Right X/8 */
+#define BBQ (5<<10)  /* Box Block Quadrants */
+#define BRL (6<<10)  /* Box Braille (data is lower byte of U28XX) */
+
+#define BBS (1<<14)  /* Box Block Shades */
+#define BDB (1<<15)  /* Box Draw is Bold */
+
+/* (BDL/BDA) Light/Double/Heavy x Left/Up/Right/Down/Horizontal/Vertical      */
+/* Heavy is light+double (literally drawing light+double align to form heavy) */
+#define LL (1<<0)
+#define LU (1<<1)
+#define LR (1<<2)
+#define LD (1<<3)
+#define LH (LL+LR)
+#define LV (LU+LD)
+
+#define DL (1<<4)
+#define DU (1<<5)
+#define DR (1<<6)
+#define DD (1<<7)
+#define DH (DL+DR)
+#define DV (DU+DD)
+
+#define HL (LL+DL)
+#define HU (LU+DU)
+#define HR (LR+DR)
+#define HD (LD+DD)
+#define HH (HL+HR)
+#define HV (HU+HD)
+
+/* (BBQ) Quadrants Top/Bottom x Left/Right */
+#define TL (1<<0)
+#define TR (1<<1)
+#define BL (1<<2)
+#define BR (1<<3)
+
+/* Data for U+2500 - U+259F except dashes/diagonals */
+static const unsigned short boxdata[256] = {
+	/* light lines */
+	[0x00] = BDL + LH,       /* light horizontal */
+	[0x02] = BDL + LV,       /* light vertical */
+	[0x0c] = BDL + LD + LR,  /* light down and right */
+	[0x10] = BDL + LD + LL,  /* light down and left */
+	[0x14] = BDL + LU + LR,  /* light up and right */
+	[0x18] = BDL + LU + LL,  /* light up and left */
+	[0x1c] = BDL + LV + LR,  /* light vertical and right */
+	[0x24] = BDL + LV + LL,  /* light vertical and left */
+	[0x2c] = BDL + LH + LD,  /* light horizontal and down */
+	[0x34] = BDL + LH + LU,  /* light horizontal and up */
+	[0x3c] = BDL + LV + LH,  /* light vertical and horizontal */
+	[0x74] = BDL + LL,       /* light left */
+	[0x75] = BDL + LU,       /* light up */
+	[0x76] = BDL + LR,       /* light right */
+	[0x77] = BDL + LD,       /* light down */
+
+	/* heavy [+light] lines */
+	[0x01] = BDL + HH,
+	[0x03] = BDL + HV,
+	[0x0d] = BDL + HR + LD,
+	[0x0e] = BDL + HD + LR,
+	[0x0f] = BDL + HD + HR,
+	[0x11] = BDL + HL + LD,
+	[0x12] = BDL + HD + LL,
+	[0x13] = BDL + HD + HL,
+	[0x15] = BDL + HR + LU,
+	[0x16] = BDL + HU + LR,
+	[0x17] = BDL + HU + HR,
+	[0x19] = BDL + HL + LU,
+	[0x1a] = BDL + HU + LL,
+	[0x1b] = BDL + HU + HL,
+	[0x1d] = BDL + HR + LV,
+	[0x1e] = BDL + HU + LD + LR,
+	[0x1f] = BDL + HD + LR + LU,
+	[0x20] = BDL + HV + LR,
+	[0x21] = BDL + HU + HR + LD,
+	[0x22] = BDL + HD + HR + LU,
+	[0x23] = BDL + HV + HR,
+	[0x25] = BDL + HL + LV,
+	[0x26] = BDL + HU + LD + LL,
+	[0x27] = BDL + HD + LU + LL,
+	[0x28] = BDL + HV + LL,
+	[0x29] = BDL + HU + HL + LD,
+	[0x2a] = BDL + HD + HL + LU,
+	[0x2b] = BDL + HV + HL,
+	[0x2d] = BDL + HL + LD + LR,
+	[0x2e] = BDL + HR + LL + LD,
+	[0x2f] = BDL + HH + LD,
+	[0x30] = BDL + HD + LH,
+	[0x31] = BDL + HD + HL + LR,
+	[0x32] = BDL + HR + HD + LL,
+	[0x33] = BDL + HH + HD,
+	[0x35] = BDL + HL + LU + LR,
+	[0x36] = BDL + HR + LU + LL,
+	[0x37] = BDL + HH + LU,
+	[0x38] = BDL + HU + LH,
+	[0x39] = BDL + HU + HL + LR,
+	[0x3a] = BDL + HU + HR + LL,
+	[0x3b] = BDL + HH + HU,
+	[0x3d] = BDL + HL + LV + LR,
+	[0x3e] = BDL + HR + LV + LL,
+	[0x3f] = BDL + HH + LV,
+	[0x40] = BDL + HU + LH + LD,
+	[0x41] = BDL + HD + LH + LU,
+	[0x42] = BDL + HV + LH,
+	[0x43] = BDL + HU + HL + LD + LR,
+	[0x44] = BDL + HU + HR + LD + LL,
+	[0x45] = BDL + HD + HL + LU + LR,
+	[0x46] = BDL + HD + HR + LU + LL,
+	[0x47] = BDL + HH + HU + LD,
+	[0x48] = BDL + HH + HD + LU,
+	[0x49] = BDL + HV + HL + LR,
+	[0x4a] = BDL + HV + HR + LL,
+	[0x4b] = BDL + HV + HH,
+	[0x78] = BDL + HL,
+	[0x79] = BDL + HU,
+	[0x7a] = BDL + HR,
+	[0x7b] = BDL + HD,
+	[0x7c] = BDL + HR + LL,
+	[0x7d] = BDL + HD + LU,
+	[0x7e] = BDL + HL + LR,
+	[0x7f] = BDL + HU + LD,
+
+	/* double [+light] lines */
+	[0x50] = BDL + DH,
+	[0x51] = BDL + DV,
+	[0x52] = BDL + DR + LD,
+	[0x53] = BDL + DD + LR,
+	[0x54] = BDL + DR + DD,
+	[0x55] = BDL + DL + LD,
+	[0x56] = BDL + DD + LL,
+	[0x57] = BDL + DL + DD,
+	[0x58] = BDL + DR + LU,
+	[0x59] = BDL + DU + LR,
+	[0x5a] = BDL + DU + DR,
+	[0x5b] = BDL + DL + LU,
+	[0x5c] = BDL + DU + LL,
+	[0x5d] = BDL + DL + DU,
+	[0x5e] = BDL + DR + LV,
+	[0x5f] = BDL + DV + LR,
+	[0x60] = BDL + DV + DR,
+	[0x61] = BDL + DL + LV,
+	[0x62] = BDL + DV + LL,
+	[0x63] = BDL + DV + DL,
+	[0x64] = BDL + DH + LD,
+	[0x65] = BDL + DD + LH,
+	[0x66] = BDL + DD + DH,
+	[0x67] = BDL + DH + LU,
+	[0x68] = BDL + DU + LH,
+	[0x69] = BDL + DH + DU,
+	[0x6a] = BDL + DH + LV,
+	[0x6b] = BDL + DV + LH,
+	[0x6c] = BDL + DH + DV,
+
+	/* (light) arcs */
+	[0x6d] = BDA + LD + LR,
+	[0x6e] = BDA + LD + LL,
+	[0x6f] = BDA + LU + LL,
+	[0x70] = BDA + LU + LR,
+
+	/* Lower (Down) X/8 block (data is 8 - X) */
+	[0x81] = BBD + 7, [0x82] = BBD + 6, [0x83] = BBD + 5, [0x84] = BBD + 4,
+	[0x85] = BBD + 3, [0x86] = BBD + 2, [0x87] = BBD + 1, [0x88] = BBD + 0,
+
+	/* Left X/8 block (data is X) */
+	[0x89] = BBL + 7, [0x8a] = BBL + 6, [0x8b] = BBL + 5, [0x8c] = BBL + 4,
+	[0x8d] = BBL + 3, [0x8e] = BBL + 2, [0x8f] = BBL + 1,
+
+	/* upper 1/2 (4/8), 1/8 block (X), right 1/2, 1/8 block (8-X) */
+	[0x80] = BBU + 4, [0x94] = BBU + 1,
+	[0x90] = BBR + 4, [0x95] = BBR + 7,
+
+	/* Quadrants */
+	[0x96] = BBQ + BL,
+	[0x97] = BBQ + BR,
+	[0x98] = BBQ + TL,
+	[0x99] = BBQ + TL + BL + BR,
+	[0x9a] = BBQ + TL + BR,
+	[0x9b] = BBQ + TL + TR + BL,
+	[0x9c] = BBQ + TL + TR + BR,
+	[0x9d] = BBQ + TR,
+	[0x9e] = BBQ + BL + TR,
+	[0x9f] = BBQ + BL + TR + BR,
+
+	/* Shades, data is an alpha value in 25% units (1/4, 1/2, 3/4) */
+	[0x91] = BBS + 1, [0x92] = BBS + 2, [0x93] = BBS + 3,
+
+	/* U+2504 - U+250B, U+254C - U+254F: unsupported (dashes) */
+	/* U+2571 - U+2573: unsupported (diagonals) */
+};
diff --git a/config.def.h b/config.def.h
index 0111bd5..15defce 100644
--- a/config.def.h
+++ b/config.def.h
@@ -67,6 +67,18 @@ static unsigned int blinktimeout = 800;
  */
 static unsigned int cursorthickness = 2;
 
+/*
+ * 1: render most of the lines/blocks characters without using the font for
+ *    perfect alignment between cells (U2500 - U259F except dashes/diagonals).
+ *    Bold affects lines thickness if boxdraw_bold is not 0. Italic is ignored.
+ * 0: disable (render all U25XX glyphs normally from the font).
+ */
+const int boxdraw = 0;
+const int boxdraw_bold = 0;
+
+/* braille (U28XX):  1: render as adjacent "pixels",  0: use font */
+const int boxdraw_braille = 0;
+
 /*
  * bell volume. It must be a value between -100 and 100. Use 0 for disabling
  * it
diff --git a/st.c b/st.c
index 683493d..3262217 100644
--- a/st.c
+++ b/st.c
@@ -1215,6 +1215,9 @@ tsetchar(Rune u, const Glyph *attr, int x, int y)
 	term.dirty[y] = 1;
 	term.line[y][x] = *attr;
 	term.line[y][x].u = u;
+
+	if (isboxdraw(u))
+		term.line[y][x].mode |= ATTR_BOXDRAW;
 }
 
 void
diff --git a/st.h b/st.h
index fd3b0d8..808f5f7 100644
--- a/st.h
+++ b/st.h
@@ -33,6 +33,7 @@ enum glyph_attribute {
 	ATTR_WRAP       = 1 << 8,
 	ATTR_WIDE       = 1 << 9,
 	ATTR_WDUMMY     = 1 << 10,
+	ATTR_BOXDRAW    = 1 << 11,
 	ATTR_BOLD_FAINT = ATTR_BOLD | ATTR_FAINT,
 };
 
@@ -111,6 +112,14 @@ void *xmalloc(size_t);
 void *xrealloc(void *, size_t);
 char *xstrdup(const char *);
 
+int isboxdraw(Rune);
+ushort boxdrawindex(const Glyph *);
+#ifdef XFT_VERSION
+/* only exposed to x.c, otherwise we'll need Xft.h for the types */
+void boxdraw_xinit(Display *, Colormap, XftDraw *, Visual *);
+void drawboxes(int, int, int, int, XftColor *, XftColor *, const XftGlyphFontSpec *, int);
+#endif
+
 /* config.h globals */
 extern char *utmp;
 extern char *scroll;
@@ -124,3 +133,4 @@ extern unsigned int tabspaces;
 extern unsigned int defaultfg;
 extern unsigned int defaultbg;
 extern unsigned int defaultcs;
+extern const int boxdraw, boxdraw_bold, boxdraw_braille;
diff --git a/x.c b/x.c
index b36fb8c..fcffc21 100644
--- a/x.c
+++ b/x.c
@@ -1237,6 +1237,8 @@ xinit(int cols, int rows)
 	xsel.xtarget = XInternAtom(xw.dpy, "UTF8_STRING", 0);
 	if (xsel.xtarget == None)
 		xsel.xtarget = XA_STRING;
+
+	boxdraw_xinit(xw.dpy, xw.cmap, xw.draw, xw.vis);
 }
 
 int
@@ -1283,8 +1285,13 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
 			yp = winy + font->ascent;
 		}
 
-		/* Lookup character index with default font. */
-		glyphidx = XftCharIndex(xw.dpy, font->match, rune);
+		if (mode & ATTR_BOXDRAW) {
+			/* minor shoehorning: boxdraw uses only this ushort */
+			glyphidx = boxdrawindex(&glyphs[i]);
+		} else {
+			/* Lookup character index with default font. */
+			glyphidx = XftCharIndex(xw.dpy, font->match, rune);
+		}
 		if (glyphidx) {
 			specs[numspecs].font = font->match;
 			specs[numspecs].glyph = glyphidx;
@@ -1488,8 +1495,12 @@ xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, i
 	r.width = width;
 	XftDrawSetClipRectangles(xw.draw, winx, winy, &r, 1);
 
-	/* Render the glyphs. */
-	XftDrawGlyphFontSpec(xw.draw, fg, specs, len);
+	if (base.mode & ATTR_BOXDRAW) {
+		drawboxes(winx, winy, width / len, win.ch, fg, bg, specs, len);
+	} else {
+		/* Render the glyphs. */
+		XftDrawGlyphFontSpec(xw.draw, fg, specs, len);
+	}
 
 	/* Render underline and strikethrough. */
 	if (base.mode & ATTR_UNDERLINE) {
@@ -1532,7 +1543,7 @@ xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
 	/*
 	 * Select the right color for the right mode.
 	 */
-	g.mode &= ATTR_BOLD|ATTR_ITALIC|ATTR_UNDERLINE|ATTR_STRUCK|ATTR_WIDE;
+	g.mode &= ATTR_BOLD|ATTR_ITALIC|ATTR_UNDERLINE|ATTR_STRUCK|ATTR_WIDE|ATTR_BOXDRAW;
 
 	if (IS_SET(MODE_REVERSE)) {
 		g.mode |= ATTR_REVERSE;
-- 
2.44.0


From 00baf486b1cec8d23fde5dc032afb579eb3558a3 Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Tue, 17 May 2022 22:14:36 +0200
Subject: [PATCH 03/12] Added ligatures patch

---
 Makefile  |   5 +-
 config.mk |   6 ++-
 hb.c      | 148 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 hb.h      |   6 +++
 st.c      |   3 +-
 st.h      |   4 +-
 win.h     |   2 +-
 x.c       |  16 ++++--
 8 files changed, 180 insertions(+), 10 deletions(-)
 create mode 100644 hb.c
 create mode 100644 hb.h

diff --git a/Makefile b/Makefile
index a64b4c2..ab3549a 100644
--- a/Makefile
+++ b/Makefile
@@ -4,7 +4,7 @@
 
 include config.mk
 
-SRC = st.c x.c boxdraw.c
+SRC = st.c x.c boxdraw.c hb.c
 OBJ = $(SRC:.c=.o)
 
 all: st
@@ -16,7 +16,8 @@ config.h:
 	$(CC) $(STCFLAGS) -c $<
 
 st.o: config.h st.h win.h
-x.o: arg.h config.h st.h win.h
+x.o: arg.h config.h st.h win.h hb.h
+hb.o: st.h
 boxdraw.o: config.h st.h boxdraw_data.h
 
 $(OBJ): config.h config.mk
diff --git a/config.mk b/config.mk
index 7f35f71..ca22b00 100644
--- a/config.mk
+++ b/config.mk
@@ -15,10 +15,12 @@ PKG_CONFIG = pkg-config
 # includes and libs
 INCS = -I$(X11INC) \
        `$(PKG_CONFIG) --cflags fontconfig` \
-       `$(PKG_CONFIG) --cflags freetype2`
+       `$(PKG_CONFIG) --cflags freetype2` \
+       `$(PKG_CONFIG) --cflags harfbuzz`
 LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft \
        `$(PKG_CONFIG) --libs fontconfig` \
-       `$(PKG_CONFIG) --libs freetype2`
+       `$(PKG_CONFIG) --libs freetype2` \
+       `$(PKG_CONFIG) --libs harfbuzz`
 
 # flags
 STCPPFLAGS = -DVERSION=\"$(VERSION)\" -D_XOPEN_SOURCE=600
diff --git a/hb.c b/hb.c
new file mode 100644
index 0000000..6b355a9
--- /dev/null
+++ b/hb.c
@@ -0,0 +1,148 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <X11/Xft/Xft.h>
+#include <hb.h>
+#include <hb-ft.h>
+
+#include "st.h"
+
+#define FEATURE(c1,c2,c3,c4) { .tag = HB_TAG(c1,c2,c3,c4), .value = 1, .start = HB_FEATURE_GLOBAL_START, .end = HB_FEATURE_GLOBAL_END }
+
+void hbtransformsegment(XftFont *xfont, const Glyph *string, hb_codepoint_t *codepoints, int start, int length);
+hb_font_t *hbfindfont(XftFont *match);
+
+typedef struct {
+	XftFont *match;
+	hb_font_t *font;
+} HbFontMatch;
+
+static int hbfontslen = 0;
+static HbFontMatch *hbfontcache = NULL;
+
+/*
+ * Replace 0 with a list of font features, wrapped in FEATURE macro, e.g.
+ * FEATURE('c', 'a', 'l', 't'), FEATURE('d', 'l', 'i', 'g')
+ */
+hb_feature_t features[] = { 0 };
+
+void
+hbunloadfonts()
+{
+	for (int i = 0; i < hbfontslen; i++) {
+		hb_font_destroy(hbfontcache[i].font);
+		XftUnlockFace(hbfontcache[i].match);
+	}
+
+	if (hbfontcache != NULL) {
+		free(hbfontcache);
+		hbfontcache = NULL;
+	}
+	hbfontslen = 0;
+}
+
+hb_font_t *
+hbfindfont(XftFont *match)
+{
+	for (int i = 0; i < hbfontslen; i++) {
+		if (hbfontcache[i].match == match)
+			return hbfontcache[i].font;
+	}
+
+	/* Font not found in cache, caching it now. */
+	hbfontcache = realloc(hbfontcache, sizeof(HbFontMatch) * (hbfontslen + 1));
+	FT_Face face = XftLockFace(match);
+	hb_font_t *font = hb_ft_font_create(face, NULL);
+	if (font == NULL)
+		die("Failed to load Harfbuzz font.");
+
+	hbfontcache[hbfontslen].match = match;
+	hbfontcache[hbfontslen].font = font;
+	hbfontslen += 1;
+
+	return font;
+}
+
+void
+hbtransform(XftGlyphFontSpec *specs, const Glyph *glyphs, size_t len, int x, int y)
+{
+	int start = 0, length = 1, gstart = 0;
+	hb_codepoint_t *codepoints = calloc((unsigned int)len, sizeof(hb_codepoint_t));
+
+	for (int idx = 1, specidx = 1; idx < len; idx++) {
+		if (glyphs[idx].mode & ATTR_WDUMMY) {
+			length += 1;
+			continue;
+		}
+
+		if (specs[specidx].font != specs[start].font || ATTRCMP(glyphs[gstart], glyphs[idx]) || selected(x + idx, y) != selected(x + gstart, y)) {
+			hbtransformsegment(specs[start].font, glyphs, codepoints, gstart, length);
+
+			/* Reset the sequence. */
+			length = 1;
+			start = specidx;
+			gstart = idx;
+		} else {
+			length += 1;
+		}
+
+		specidx++;
+	}
+
+	/* EOL. */
+	hbtransformsegment(specs[start].font, glyphs, codepoints, gstart, length);
+
+	/* Apply the transformation to glyph specs. */
+	for (int i = 0, specidx = 0; i < len; i++) {
+		if (glyphs[i].mode & ATTR_WDUMMY)
+			continue;
+		if (glyphs[i].mode & ATTR_BOXDRAW) {
+			specidx++;
+			continue;
+		}
+
+		if (codepoints[i] != specs[specidx].glyph)
+			((Glyph *)glyphs)[i].mode |= ATTR_LIGA;
+
+		specs[specidx++].glyph = codepoints[i];
+	}
+
+	free(codepoints);
+}
+
+void
+hbtransformsegment(XftFont *xfont, const Glyph *string, hb_codepoint_t *codepoints, int start, int length)
+{
+	hb_font_t *font = hbfindfont(xfont);
+	if (font == NULL)
+		return;
+
+	Rune rune;
+	ushort mode = USHRT_MAX;
+	hb_buffer_t *buffer = hb_buffer_create();
+	hb_buffer_set_direction(buffer, HB_DIRECTION_LTR);
+
+	/* Fill buffer with codepoints. */
+	for (int i = start; i < (start+length); i++) {
+		rune = string[i].u;
+		mode = string[i].mode;
+		if (mode & ATTR_WDUMMY)
+			rune = 0x0020;
+		hb_buffer_add_codepoints(buffer, &rune, 1, 0, 1);
+	}
+
+	/* Shape the segment. */
+	hb_shape(font, buffer, features, sizeof(features));
+
+	/* Get new glyph info. */
+	hb_glyph_info_t *info = hb_buffer_get_glyph_infos(buffer, NULL);
+
+	/* Write new codepoints. */
+	for (int i = 0; i < length; i++) {
+		hb_codepoint_t gid = info[i].codepoint;
+		codepoints[start+i] = gid;
+	}
+
+	/* Cleanup. */
+	hb_buffer_destroy(buffer);
+}
diff --git a/hb.h b/hb.h
new file mode 100644
index 0000000..07888df
--- /dev/null
+++ b/hb.h
@@ -0,0 +1,6 @@
+#include <X11/Xft/Xft.h>
+#include <hb.h>
+#include <hb-ft.h>
+
+void hbunloadfonts();
+void hbtransform(XftGlyphFontSpec *, const Glyph *, size_t, int, int);
diff --git a/st.c b/st.c
index 3262217..3428707 100644
--- a/st.c
+++ b/st.c
@@ -2666,7 +2666,8 @@ draw(void)
 
 	drawregion(0, 0, term.col, term.row);
 	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
-			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
+			term.ocx, term.ocy, term.line[term.ocy][term.ocx],
+			term.line[term.ocy], term.col);
 	term.ocx = cx;
 	term.ocy = term.c.y;
 	xfinishdraw();
diff --git a/st.h b/st.h
index 808f5f7..b889a88 100644
--- a/st.h
+++ b/st.h
@@ -11,7 +11,8 @@
 #define DIVCEIL(n, d)		(((n) + ((d) - 1)) / (d))
 #define DEFAULT(a, b)		(a) = (a) ? (a) : (b)
 #define LIMIT(x, a, b)		(x) = (x) < (a) ? (a) : (x) > (b) ? (b) : (x)
-#define ATTRCMP(a, b)		((a).mode != (b).mode || (a).fg != (b).fg || \
+#define ATTRCMP(a, b)		(((a).mode & (~ATTR_WRAP) & (~ATTR_LIGA)) != ((b).mode & (~ATTR_WRAP) & (~ATTR_LIGA)) || \
+				(a).fg != (b).fg || \
 				(a).bg != (b).bg)
 #define TIMEDIFF(t1, t2)	((t1.tv_sec-t2.tv_sec)*1000 + \
 				(t1.tv_nsec-t2.tv_nsec)/1E6)
@@ -34,6 +35,7 @@ enum glyph_attribute {
 	ATTR_WIDE       = 1 << 9,
 	ATTR_WDUMMY     = 1 << 10,
 	ATTR_BOXDRAW    = 1 << 11,
+	ATTR_LIGA       = 1 << 12,
 	ATTR_BOLD_FAINT = ATTR_BOLD | ATTR_FAINT,
 };
 
diff --git a/win.h b/win.h
index 6de960d..94679e4 100644
--- a/win.h
+++ b/win.h
@@ -25,7 +25,7 @@ enum win_mode {
 
 void xbell(void);
 void xclipcopy(void);
-void xdrawcursor(int, int, Glyph, int, int, Glyph);
+void xdrawcursor(int, int, Glyph, int, int, Glyph, Line, int);
 void xdrawline(Line, int, int, int);
 void xfinishdraw(void);
 void xloadcols(void);
diff --git a/x.c b/x.c
index fcffc21..f71b616 100644
--- a/x.c
+++ b/x.c
@@ -19,6 +19,7 @@ char *argv0;
 #include "arg.h"
 #include "st.h"
 #include "win.h"
+#include "hb.h"
 
 /* types used in config.h */
 typedef struct {
@@ -1062,6 +1063,9 @@ xunloadfont(Font *f)
 void
 xunloadfonts(void)
 {
+	/* Clear Harfbuzz font cache. */
+	hbunloadfonts();
+
 	/* Free the loaded fonts in the font cache.  */
 	while (frclen > 0)
 		XftFontClose(xw.dpy, frc[--frclen].font);
@@ -1263,7 +1267,7 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
 		mode = glyphs[i].mode;
 
 		/* Skip dummy wide-character spacing. */
-		if (mode == ATTR_WDUMMY)
+		if (mode & ATTR_WDUMMY)
 			continue;
 
 		/* Determine font for glyph if different from previous glyph. */
@@ -1375,6 +1379,9 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
 		numspecs++;
 	}
 
+	/* Harfbuzz transformation for ligatures. */
+	hbtransform(specs, glyphs, len, x, y);
+
 	return numspecs;
 }
 
@@ -1528,14 +1535,17 @@ xdrawglyph(Glyph g, int x, int y)
 }
 
 void
-xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
+xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og, Line line, int len)
 {
 	Color drawcol;
 
 	/* remove the old cursor */
 	if (selected(ox, oy))
 		og.mode ^= ATTR_REVERSE;
-	xdrawglyph(og, ox, oy);
+
+	/* Redraw the line where cursor was previously.
+	 * It will restore the ligatures broken by the cursor. */
+	xdrawline(line, 0, oy, len);
 
 	if (IS_SET(MODE_HIDE))
 		return;
-- 
2.44.0


From 96d337247036f285081926f16703ebdb5c642940 Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Tue, 17 May 2022 22:15:00 +0200
Subject: [PATCH 04/12] Added scrollback patch

---
 config.def.h |   2 +
 st.c         | 127 +++++++++++++++++++++++++++++++++++++++------------
 st.h         |   2 +
 3 files changed, 103 insertions(+), 28 deletions(-)

diff --git a/config.def.h b/config.def.h
index 15defce..21b8230 100644
--- a/config.def.h
+++ b/config.def.h
@@ -213,6 +213,8 @@ static Shortcut shortcuts[] = {
 	{ TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
 	{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
 	{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
+	{ ShiftMask,            XK_Page_Up,     kscrollup,      {.i = -1} },
+	{ ShiftMask,            XK_Page_Down,   kscrolldown,    {.i = -1} },
 };
 
 /*
diff --git a/st.c b/st.c
index 3428707..e6492ae 100644
--- a/st.c
+++ b/st.c
@@ -35,6 +35,7 @@
 #define ESC_ARG_SIZ   16
 #define STR_BUF_SIZ   ESC_BUF_SIZ
 #define STR_ARG_SIZ   ESC_ARG_SIZ
+#define HISTSIZE      2000
 
 /* macros */
 #define IS_SET(flag)		((term.mode & (flag)) != 0)
@@ -42,6 +43,9 @@
 #define ISCONTROLC1(c)		(BETWEEN(c, 0x80, 0x9f))
 #define ISCONTROL(c)		(ISCONTROLC0(c) || ISCONTROLC1(c))
 #define ISDELIM(u)		(u && wcschr(worddelimiters, u))
+#define TLINE(y)		((y) < term.scr ? term.hist[((y) + term.histi - \
+				term.scr + HISTSIZE + 1) % HISTSIZE] : \
+				term.line[(y) - term.scr])
 
 enum term_mode {
 	MODE_WRAP        = 1 << 0,
@@ -115,6 +119,9 @@ typedef struct {
 	int col;      /* nb col */
 	Line *line;   /* screen */
 	Line *alt;    /* alternate screen */
+	Line hist[HISTSIZE]; /* history buffer */
+	int histi;    /* history index */
+	int scr;      /* scroll back */
 	int *dirty;   /* dirtyness of lines */
 	TCursor c;    /* cursor */
 	int ocx;      /* old cursor col */
@@ -185,8 +192,8 @@ static void tnewline(int);
 static void tputtab(int);
 static void tputc(Rune);
 static void treset(void);
-static void tscrollup(int, int);
-static void tscrolldown(int, int);
+static void tscrollup(int, int, int);
+static void tscrolldown(int, int, int);
 static void tsetattr(const int *, int);
 static void tsetchar(Rune, const Glyph *, int, int);
 static void tsetdirt(int, int);
@@ -409,10 +416,10 @@ tlinelen(int y)
 {
 	int i = term.col;
 
-	if (term.line[y][i - 1].mode & ATTR_WRAP)
+	if (TLINE(y)[i - 1].mode & ATTR_WRAP)
 		return i;
 
-	while (i > 0 && term.line[y][i - 1].u == ' ')
+	while (i > 0 && TLINE(y)[i - 1].u == ' ')
 		--i;
 
 	return i;
@@ -521,7 +528,7 @@ selsnap(int *x, int *y, int direction)
 		 * Snap around if the word wraps around at the end or
 		 * beginning of a line.
 		 */
-		prevgp = &term.line[*y][*x];
+		prevgp = &TLINE(*y)[*x];
 		prevdelim = ISDELIM(prevgp->u);
 		for (;;) {
 			newx = *x + direction;
@@ -536,14 +543,14 @@ selsnap(int *x, int *y, int direction)
 					yt = *y, xt = *x;
 				else
 					yt = newy, xt = newx;
-				if (!(term.line[yt][xt].mode & ATTR_WRAP))
+				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
 					break;
 			}
 
 			if (newx >= tlinelen(newy))
 				break;
 
-			gp = &term.line[newy][newx];
+			gp = &TLINE(newy)[newx];
 			delim = ISDELIM(gp->u);
 			if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
 					|| (delim && gp->u != prevgp->u)))
@@ -564,14 +571,14 @@ selsnap(int *x, int *y, int direction)
 		*x = (direction < 0) ? 0 : term.col - 1;
 		if (direction < 0) {
 			for (; *y > 0; *y += direction) {
-				if (!(term.line[*y-1][term.col-1].mode
+				if (!(TLINE(*y-1)[term.col-1].mode
 						& ATTR_WRAP)) {
 					break;
 				}
 			}
 		} else if (direction > 0) {
 			for (; *y < term.row-1; *y += direction) {
-				if (!(term.line[*y][term.col-1].mode
+				if (!(TLINE(*y)[term.col-1].mode
 						& ATTR_WRAP)) {
 					break;
 				}
@@ -602,13 +609,13 @@ getsel(void)
 		}
 
 		if (sel.type == SEL_RECTANGULAR) {
-			gp = &term.line[y][sel.nb.x];
+			gp = &TLINE(y)[sel.nb.x];
 			lastx = sel.ne.x;
 		} else {
-			gp = &term.line[y][sel.nb.y == y ? sel.nb.x : 0];
+			gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
 			lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
 		}
-		last = &term.line[y][MIN(lastx, linelen-1)];
+		last = &TLINE(y)[MIN(lastx, linelen-1)];
 		while (last >= gp && last->u == ' ')
 			--last;
 
@@ -844,6 +851,9 @@ void
 ttywrite(const char *s, size_t n, int may_echo)
 {
 	const char *next;
+	Arg arg = (Arg) { .i = term.scr };
+
+	kscrolldown(&arg);
 
 	if (may_echo && IS_SET(MODE_ECHO))
 		twrite(s, n, 1);
@@ -1055,12 +1065,52 @@ tswapscreen(void)
 }
 
 void
-tscrolldown(int orig, int n)
+kscrolldown(const Arg* a)
+{
+	int n = a->i;
+
+	if (n < 0)
+		n = term.row + n;
+
+	if (n > term.scr)
+		n = term.scr;
+
+	if (term.scr > 0) {
+		term.scr -= n;
+		selscroll(0, -n);
+		tfulldirt();
+	}
+}
+
+void
+kscrollup(const Arg* a)
+{
+	int n = a->i;
+
+	if (n < 0)
+		n = term.row + n;
+
+	if (term.scr <= HISTSIZE-n) {
+		term.scr += n;
+		selscroll(0, n);
+		tfulldirt();
+	}
+}
+
+void
+tscrolldown(int orig, int n, int copyhist)
 {
 	int i;
 	Line temp;
 
 	LIMIT(n, 0, term.bot-orig+1);
+	if (copyhist) {
+		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
+		temp = term.hist[term.histi];
+		term.hist[term.histi] = term.line[term.bot];
+		term.line[term.bot] = temp;
+	}
+
 
 	tsetdirt(orig, term.bot-n);
 	tclearregion(0, term.bot-n+1, term.col-1, term.bot);
@@ -1071,17 +1121,28 @@ tscrolldown(int orig, int n)
 		term.line[i-n] = temp;
 	}
 
-	selscroll(orig, n);
+	if (term.scr == 0)
+		selscroll(orig, n);
 }
 
 void
-tscrollup(int orig, int n)
+tscrollup(int orig, int n, int copyhist)
 {
 	int i;
 	Line temp;
 
 	LIMIT(n, 0, term.bot-orig+1);
 
+	if (copyhist) {
+		term.histi = (term.histi + 1) % HISTSIZE;
+		temp = term.hist[term.histi];
+		term.hist[term.histi] = term.line[orig];
+		term.line[orig] = temp;
+	}
+
+	if (term.scr > 0 && term.scr < HISTSIZE)
+		term.scr = MIN(term.scr + n, HISTSIZE-1);
+
 	tclearregion(0, orig, term.col-1, orig+n-1);
 	tsetdirt(orig+n, term.bot);
 
@@ -1091,7 +1152,8 @@ tscrollup(int orig, int n)
 		term.line[i+n] = temp;
 	}
 
-	selscroll(orig, -n);
+	if (term.scr == 0)
+		selscroll(orig, -n);
 }
 
 void
@@ -1120,7 +1182,7 @@ tnewline(int first_col)
 	int y = term.c.y;
 
 	if (y == term.bot) {
-		tscrollup(term.top, 1);
+		tscrollup(term.top, 1, 1);
 	} else {
 		y++;
 	}
@@ -1288,14 +1350,14 @@ void
 tinsertblankline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrolldown(term.c.y, n);
+		tscrolldown(term.c.y, n, 0);
 }
 
 void
 tdeleteline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrollup(term.c.y, n);
+		tscrollup(term.c.y, n, 0);
 }
 
 int32_t
@@ -1733,11 +1795,11 @@ csihandle(void)
 	case 'S': /* SU -- Scroll <n> line up */
 		if (csiescseq.priv) break;
 		DEFAULT(csiescseq.arg[0], 1);
-		tscrollup(term.top, csiescseq.arg[0]);
+		tscrollup(term.top, csiescseq.arg[0], 0);
 		break;
 	case 'T': /* SD -- Scroll <n> line down */
 		DEFAULT(csiescseq.arg[0], 1);
-		tscrolldown(term.top, csiescseq.arg[0]);
+		tscrolldown(term.top, csiescseq.arg[0], 0);
 		break;
 	case 'L': /* IL -- Insert <n> blank lines */
 		DEFAULT(csiescseq.arg[0], 1);
@@ -2313,7 +2375,7 @@ eschandle(uchar ascii)
 		return 0;
 	case 'D': /* IND -- Linefeed */
 		if (term.c.y == term.bot) {
-			tscrollup(term.top, 1);
+			tscrollup(term.top, 1, 1);
 		} else {
 			tmoveto(term.c.x, term.c.y+1);
 		}
@@ -2326,7 +2388,7 @@ eschandle(uchar ascii)
 		break;
 	case 'M': /* RI -- Reverse index */
 		if (term.c.y == term.top) {
-			tscrolldown(term.top, 1);
+			tscrolldown(term.top, 1, 1);
 		} else {
 			tmoveto(term.c.x, term.c.y-1);
 		}
@@ -2549,7 +2611,7 @@ twrite(const char *buf, int buflen, int show_ctrl)
 void
 tresize(int col, int row)
 {
-	int i;
+	int i, j;
 	int minrow = MIN(row, term.row);
 	int mincol = MIN(col, term.col);
 	int *bp;
@@ -2586,6 +2648,14 @@ tresize(int col, int row)
 	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
 	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
 
+	for (i = 0; i < HISTSIZE; i++) {
+		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
+		for (j = mincol; j < col; j++) {
+			term.hist[i][j] = term.c.attr;
+			term.hist[i][j].u = ' ';
+		}
+	}
+
 	/* resize each row to new width, zero-pad if needed */
 	for (i = 0; i < minrow; i++) {
 		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
@@ -2644,7 +2714,7 @@ drawregion(int x1, int y1, int x2, int y2)
 			continue;
 
 		term.dirty[y] = 0;
-		xdrawline(term.line[y], x1, y, x2);
+		xdrawline(TLINE(y), x1, y, x2);
 	}
 }
 
@@ -2665,9 +2735,10 @@ draw(void)
 		cx--;
 
 	drawregion(0, 0, term.col, term.row);
-	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
-			term.ocx, term.ocy, term.line[term.ocy][term.ocx],
-			term.line[term.ocy], term.col);
+	if (term.scr == 0)
+		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
+				term.ocx, term.ocy, term.line[term.ocy][term.ocx],
+				term.line[term.ocy], term.col);
 	term.ocx = cx;
 	term.ocy = term.c.y;
 	xfinishdraw();
diff --git a/st.h b/st.h
index b889a88..0cfab7b 100644
--- a/st.h
+++ b/st.h
@@ -84,6 +84,8 @@ void die(const char *, ...);
 void redraw(void);
 void draw(void);
 
+void kscrolldown(const Arg *);
+void kscrollup(const Arg *);
 void printscreen(const Arg *);
 void printsel(const Arg *);
 void sendbreak(const Arg *);
-- 
2.44.0


From e2a5987fcbc5dc235e697293de08726c914526d9 Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Tue, 17 May 2022 22:16:01 +0200
Subject: [PATCH 05/12] Added visualbell patch

---
 config.def.h |  8 ++++++++
 x.c          | 35 +++++++++++++++++++++++++++++++++++
 2 files changed, 43 insertions(+)

diff --git a/config.def.h b/config.def.h
index 21b8230..8ddad2b 100644
--- a/config.def.h
+++ b/config.def.h
@@ -85,6 +85,14 @@ const int boxdraw_braille = 0;
  */
 static int bellvolume = 0;
 
+/* visual-bell timeout in ms (0 to disable visual-bell) */
+static int vbelltimeout = 150;
+
+/* choose predefined visual-bell cells to inverse, or define your own logic */
+#define VBCELL x==0 || x==right || y==0 || y==bottom  /* border */
+// #define VBCELL 1  /* all cells - whole screen */
+// #define VBCELL y==bottom && x>right-2  /* bottom-right */
+
 /* default TERM value */
 char *termname = "st-256color";
 
diff --git a/x.c b/x.c
index f71b616..0d1b85e 100644
--- a/x.c
+++ b/x.c
@@ -1660,6 +1660,27 @@ xsettitle(char *p)
 	XFree(prop.value);
 }
 
+
+static int vbellset = 0; /* 1 during visual bell, 0 otherwise */
+static struct timespec lastvbell = {0};
+
+static int
+isvbellcell(int x, int y)
+{
+	int right = win.tw / win.cw - 1, bottom = win.th / win.ch - 1;
+	return VBCELL;  /* logic condition defined at config.h */
+}
+
+static void
+vbellbegin() {
+	clock_gettime(CLOCK_MONOTONIC, &lastvbell);
+	if (vbellset)
+		return;
+	vbellset = 1;
+	redraw();
+	XFlush(xw.dpy);
+}
+
 int
 xstartdraw(void)
 {
@@ -1681,6 +1702,8 @@ xdrawline(Line line, int x1, int y1, int x2)
 			continue;
 		if (selected(x, y1))
 			new.mode ^= ATTR_REVERSE;
+		if (vbellset && isvbellcell(x, y1))
+			new.mode ^= ATTR_REVERSE;
 		if (i > 0 && ATTRCMP(base, new)) {
 			xdrawglyphfontspecs(specs, base, i, ox, y1);
 			specs += i;
@@ -1781,6 +1804,8 @@ xbell(void)
 		xseturgency(1);
 	if (bellvolume)
 		XkbBell(xw.dpy, xw.win, bellvolume, (Atom)NULL);
+	if (vbelltimeout)
+		vbellbegin();
 }
 
 void
@@ -2029,6 +2054,16 @@ run(void)
 			}
 		}
 
+		if (vbellset) {
+			double remain = vbelltimeout - TIMEDIFF(now, lastvbell);
+			if (remain <= 0) {
+				vbellset = 0;
+				redraw();
+			} else if (timeout < 0 || remain < timeout) {
+				timeout = remain;
+			}
+		}
+
 		draw();
 		XFlush(xw.dpy);
 		drawing = 0;
-- 
2.44.0


From 4cc93709f585ab65909d015ab0998e1a4057718a Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Tue, 17 May 2022 22:16:24 +0200
Subject: [PATCH 06/12] Added mousescroll patch

---
 config.def.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/config.def.h b/config.def.h
index 8ddad2b..9e88b23 100644
--- a/config.def.h
+++ b/config.def.h
@@ -198,9 +198,9 @@ static MouseShortcut mshortcuts[] = {
 	/* mask                 button   function        argument       release */
 	{ XK_ANY_MOD,           Button2, selpaste,       {.i = 0},      1 },
 	{ ShiftMask,            Button4, ttysend,        {.s = "\033[5;2~"} },
-	{ XK_ANY_MOD,           Button4, ttysend,        {.s = "\031"} },
+	{ XK_ANY_MOD,           Button4, kscrollup,      {.i = 2} },
 	{ ShiftMask,            Button5, ttysend,        {.s = "\033[6;2~"} },
-	{ XK_ANY_MOD,           Button5, ttysend,        {.s = "\005"} },
+	{ XK_ANY_MOD,           Button5, kscrolldown,    {.i = 2} }
 };
 
 /* Internal keyboard shortcuts. */
-- 
2.44.0


From 7a1029da96ce673c92ea75c6b0190a3f78c3af4f Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Tue, 17 May 2022 22:17:00 +0200
Subject: [PATCH 07/12] Added xresources patch

---
 x.c | 115 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 115 insertions(+)

diff --git a/x.c b/x.c
index 0d1b85e..ab297d0 100644
--- a/x.c
+++ b/x.c
@@ -14,6 +14,7 @@
 #include <X11/keysym.h>
 #include <X11/Xft/Xft.h>
 #include <X11/XKBlib.h>
+#include <X11/Xresource.h>
 
 char *argv0;
 #include "arg.h"
@@ -2070,6 +2071,118 @@ run(void)
 	}
 }
 
+
+#define XRESOURCE_LOAD_META(NAME)					\
+	if(!XrmGetResource(xrdb, "st." NAME, "st." NAME, &type, &ret))	\
+		XrmGetResource(xrdb, "*." NAME, "*." NAME, &type, &ret); \
+	if (ret.addr != NULL && !strncmp("String", type, 64))
+
+#define XRESOURCE_LOAD_STRING(NAME, DST)	\
+	XRESOURCE_LOAD_META(NAME)		\
+		DST = ret.addr;
+
+#define XRESOURCE_LOAD_CHAR(NAME, DST)		\
+	XRESOURCE_LOAD_META(NAME)		\
+		DST = ret.addr[0];
+
+#define XRESOURCE_LOAD_INTEGER(NAME, DST)		\
+	XRESOURCE_LOAD_META(NAME)			\
+		DST = strtoul(ret.addr, NULL, 10);
+
+#define XRESOURCE_LOAD_FLOAT(NAME, DST)		\
+	XRESOURCE_LOAD_META(NAME)		\
+		DST = strtof(ret.addr, NULL);
+
+void
+xrdb_load(void)
+{
+	/* XXX */
+	char *xrm;
+	char *type;
+	XrmDatabase xrdb;
+	XrmValue ret;
+	Display *dpy;
+
+	if(!(dpy = XOpenDisplay(NULL)))
+		die("Can't open display\n");
+
+	XrmInitialize();
+	xrm = XResourceManagerString(dpy);
+
+	if (xrm != NULL) {
+		xrdb = XrmGetStringDatabase(xrm);
+
+		/* handling colors here without macros to do via loop. */
+		int i = 0;
+		char loadValue[12] = "";
+		for (i = 0; i < 256; i++)
+		{
+			sprintf(loadValue, "%s%d", "st.color", i);
+
+			if(!XrmGetResource(xrdb, loadValue, loadValue, &type, &ret))
+			{
+				sprintf(loadValue, "%s%d", "*.color", i);
+				if (!XrmGetResource(xrdb, loadValue, loadValue, &type, &ret))
+					/* reset if not found (unless in range for defaults). */
+					if (i > 15)
+						colorname[i] = NULL;
+			}
+
+			if (ret.addr != NULL && !strncmp("String", type, 64))
+				colorname[i] = ret.addr;
+		}
+
+		XRESOURCE_LOAD_STRING("foreground", colorname[defaultfg]);
+		XRESOURCE_LOAD_STRING("background", colorname[defaultbg]);
+		XRESOURCE_LOAD_STRING("cursorColor", colorname[defaultcs])
+		else {
+		  // this looks confusing because we are chaining off of the if
+		  // in the macro. probably we should be wrapping everything blocks
+		  // so this isn't possible...
+		  defaultcs = defaultfg;
+		}
+		XRESOURCE_LOAD_STRING("reverse-cursor", colorname[defaultrcs])
+		else {
+		  // see above.
+		  defaultrcs = defaultbg;
+		}
+
+		XRESOURCE_LOAD_STRING("font", font);
+		XRESOURCE_LOAD_STRING("termname", termname);
+
+		XRESOURCE_LOAD_INTEGER("blinktimeout", blinktimeout);
+		XRESOURCE_LOAD_INTEGER("bellvolume", bellvolume);
+		XRESOURCE_LOAD_INTEGER("borderpx", borderpx);
+		XRESOURCE_LOAD_INTEGER("cursorshape", cursorshape);
+
+		XRESOURCE_LOAD_FLOAT("cwscale", cwscale);
+		XRESOURCE_LOAD_FLOAT("chscale", chscale);
+	}
+	XFlush(dpy);
+}
+
+void
+reload(int sig)
+{
+	xrdb_load();
+
+	/* colors, fonts */
+	xloadcols();
+	xunloadfonts();
+	xloadfonts(font, 0);
+
+	/* pretend the window just got resized */
+	cresize(win.w, win.h);
+
+	redraw();
+
+	/* triggers re-render if we're visible. */
+	ttywrite("\033[O", 3, 1);
+
+	signal(SIGUSR1, reload);
+}
+
+
 void
 usage(void)
 {
@@ -2143,6 +2256,8 @@ run:
 
 	setlocale(LC_CTYPE, "");
 	XSetLocaleModifiers("");
+	xrdb_load();
+	signal(SIGUSR1, reload);
 	cols = MAX(cols, 1);
 	rows = MAX(rows, 1);
 	tnew(cols, rows);
-- 
2.44.0


From 099ad9da9ec19ba7708c5c4f7fa90538e0931d2f Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Tue, 17 May 2022 22:19:17 +0200
Subject: [PATCH 08/12] Added font2 patch

---
 config.def.h |   8 ++++
 x.c          | 101 +++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 109 insertions(+)

diff --git a/config.def.h b/config.def.h
index 9e88b23..126d8dd 100644
--- a/config.def.h
+++ b/config.def.h
@@ -7,6 +7,14 @@
  */
 static char *font = "Hasklug Nerd Font Mono:pixelsize=14:antialias=true:autohint=true";
 static int borderpx = 2;
+/* Spare fonts */
+static char *font2[] = {
+	"Symbola", // Emojis support
+	"Kochi Mincho", // Japanese support
+	"Kochi Gothic", // Japanese support 2
+/*	"Inconsolata for Powerline:pixelsize=12:antialias=true:autohint=true", */
+/*	"Hack Nerd Font Mono:pixelsize=11:antialias=true:autohint=true", */
+};
 
 /*
  * What program is execed by st depends of these precedence rules:
diff --git a/x.c b/x.c
index ab297d0..6c588a6 100644
--- a/x.c
+++ b/x.c
@@ -159,6 +159,8 @@ static void xhints(void);
 static int xloadcolor(int, const char *, Color *);
 static int xloadfont(Font *, FcPattern *);
 static void xloadfonts(const char *, double);
+static int xloadsparefont(FcPattern *, int);
+static void xloadsparefonts(void);
 static void xunloadfont(Font *);
 static void xunloadfonts(void);
 static void xsetenv(void);
@@ -308,6 +310,7 @@ zoomabs(const Arg *arg)
 {
 	xunloadfonts();
 	xloadfonts(usedfont, arg->f);
+	xloadsparefonts();
 	cresize(0, 0);
 	redraw();
 	xhints();
@@ -1052,6 +1055,101 @@ xloadfonts(const char *fontstr, double fontsize)
 	FcPatternDestroy(pattern);
 }
 
+int
+xloadsparefont(FcPattern *pattern, int flags)
+{
+	FcPattern *match;
+	FcResult result;
+	
+	match = FcFontMatch(NULL, pattern, &result);
+	if (!match) {
+		return 1;
+	}
+
+	if (!(frc[frclen].font = XftFontOpenPattern(xw.dpy, match))) {
+		FcPatternDestroy(match);
+		return 1;
+	}
+
+	frc[frclen].flags = flags;
+	/* Believe U+0000 glyph will present in each default font */
+	frc[frclen].unicodep = 0;
+	frclen++;
+
+	return 0;
+}
+
+void
+xloadsparefonts(void)
+{
+	FcPattern *pattern;
+	double sizeshift, fontval;
+	int fc;
+	char **fp;
+
+	if (frclen != 0)
+		die("can't embed spare fonts. cache isn't empty");
+
+	/* Calculate count of spare fonts */
+	fc = sizeof(font2) / sizeof(*font2);
+	if (fc == 0)
+		return;
+
+	/* Allocate memory for cache entries. */
+	if (frccap < 4 * fc) {
+		frccap += 4 * fc - frccap;
+		frc = xrealloc(frc, frccap * sizeof(Fontcache));
+	}
+
+	for (fp = font2; fp - font2 < fc; ++fp) {
+	
+		if (**fp == '-')
+			pattern = XftXlfdParse(*fp, False, False);
+		else
+			pattern = FcNameParse((FcChar8 *)*fp);
+	
+		if (!pattern)
+			die("can't open spare font %s\n", *fp);
+	   		
+		if (defaultfontsize > 0) {
+			sizeshift = usedfontsize - defaultfontsize;
+			if (sizeshift != 0 &&
+					FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
+					FcResultMatch) {	
+				fontval += sizeshift;
+				FcPatternDel(pattern, FC_PIXEL_SIZE);
+				FcPatternDel(pattern, FC_SIZE);
+				FcPatternAddDouble(pattern, FC_PIXEL_SIZE, fontval);
+			}
+		}
+	
+		FcPatternAddBool(pattern, FC_SCALABLE, 1);
+	
+		FcConfigSubstitute(NULL, pattern, FcMatchPattern);
+		XftDefaultSubstitute(xw.dpy, xw.scr, pattern);
+	
+		if (xloadsparefont(pattern, FRC_NORMAL))
+			die("can't open spare font %s\n", *fp);
+	
+		FcPatternDel(pattern, FC_SLANT);
+		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
+		if (xloadsparefont(pattern, FRC_ITALIC))
+			die("can't open spare font %s\n", *fp);
+			
+		FcPatternDel(pattern, FC_WEIGHT);
+		FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
+		if (xloadsparefont(pattern, FRC_ITALICBOLD))
+			die("can't open spare font %s\n", *fp);
+	
+		FcPatternDel(pattern, FC_SLANT);
+		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
+		if (xloadsparefont(pattern, FRC_BOLD))
+			die("can't open spare font %s\n", *fp);
+	
+		FcPatternDestroy(pattern);
+	}
+}
+
 void
 xunloadfont(Font *f)
 {
@@ -1152,6 +1250,9 @@ xinit(int cols, int rows)
 	usedfont = (opt_font == NULL)? font : opt_font;
 	xloadfonts(usedfont, 0);
 
+	/* spare fonts */
+	xloadsparefonts();
+
 	/* colors */
 	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
 	xloadcols();
-- 
2.44.0


From 6d5c91a31ad4bdd232b4a315dcad23bf4f84eaf4 Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Tue, 17 May 2022 22:20:00 +0200
Subject: [PATCH 09/12] Added support for keypad prior and next patch

---
 config.def.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/config.def.h b/config.def.h
index 126d8dd..6f8c504 100644
--- a/config.def.h
+++ b/config.def.h
@@ -223,6 +223,8 @@ static Shortcut shortcuts[] = {
 	{ XK_ANY_MOD,           XK_Print,       printsel,       {.i =  0} },
 	{ TERMMOD,              XK_Prior,       zoom,           {.f = +1} },
 	{ TERMMOD,              XK_Next,        zoom,           {.f = -1} },
+	{ TERMMOD,              XK_KP_Prior,    zoom,           {.f = +1} },
+	{ TERMMOD,              XK_KP_Next,     zoom,           {.f = -1} },
 	{ TERMMOD,              XK_Home,        zoomreset,      {.f =  0} },
 	{ TERMMOD,              XK_C,           clipcopy,       {.i =  0} },
 	{ TERMMOD,              XK_V,           clippaste,      {.i =  0} },
-- 
2.44.0


From d9dcc40adfd5c51a6f2ea6988b5a0ab734bf4679 Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Fri, 7 Apr 2023 18:28:50 +0200
Subject: [PATCH 10/12] Added support w3m images patch

---
 x.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/x.c b/x.c
index 6c588a6..1826d9a 100644
--- a/x.c
+++ b/x.c
@@ -1786,6 +1786,8 @@ vbellbegin() {
 int
 xstartdraw(void)
 {
+	if (IS_SET(MODE_VISIBLE))
+		XCopyArea(xw.dpy, xw.win, xw.buf, dc.gc, 0, 0, win.w, win.h, 0, 0);
 	return IS_SET(MODE_VISIBLE);
 }
 
-- 
2.44.0


From 285fc338c0118148d32fbff465c0c5cefe812c3e Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Fri, 7 Apr 2023 18:39:30 +0200
Subject: [PATCH 11/12] Added hidecursor patch

---
 x.c | 32 ++++++++++++++++++++++++++++----
 1 file changed, 28 insertions(+), 4 deletions(-)

diff --git a/x.c b/x.c
index 1826d9a..47dc5ae 100644
--- a/x.c
+++ b/x.c
@@ -105,6 +105,11 @@ typedef struct {
 	Draw draw;
 	Visual *vis;
 	XSetWindowAttributes attrs;
+	/* Here, we use the term *pointer* to differentiate the cursor
+	 * one sees when hovering the mouse over the terminal from, e.g.,
+	 * a green rectangle where text would be entered. */
+	Cursor vpointer, bpointer; /* visible and hidden pointers */
+	int pointerisvisible;
 	int scr;
 	int isfixed; /* is fixed geometry? */
 	int l, t; /* left and top offset */
@@ -721,6 +726,13 @@ brelease(XEvent *e)
 void
 bmotion(XEvent *e)
 {
+	if (!xw.pointerisvisible) {
+		XDefineCursor(xw.dpy, xw.win, xw.vpointer);
+		xw.pointerisvisible = 1;
+		if (!IS_SET(MODE_MOUSEMANY))
+			xsetpointermotion(0);
+	}
+
 	if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {
 		mousereport(e);
 		return;
@@ -1233,10 +1245,10 @@ void
 xinit(int cols, int rows)
 {
 	XGCValues gcvalues;
-	Cursor cursor;
 	Window parent;
 	pid_t thispid = getpid();
 	XColor xmousefg, xmousebg;
+	Pixmap blankpm;
 
 	if (!(xw.dpy = XOpenDisplay(NULL)))
 		die("can't open display\n");
@@ -1303,8 +1315,9 @@ xinit(int cols, int rows)
 	}
 
 	/* white cursor, black outline */
-	cursor = XCreateFontCursor(xw.dpy, mouseshape);
-	XDefineCursor(xw.dpy, xw.win, cursor);
+	xw.pointerisvisible = 1;
+	xw.vpointer = XCreateFontCursor(xw.dpy, mouseshape);
+	XDefineCursor(xw.dpy, xw.win, xw.vpointer);
 
 	if (XParseColor(xw.dpy, xw.cmap, colorname[mousefg], &xmousefg) == 0) {
 		xmousefg.red   = 0xffff;
@@ -1318,7 +1331,10 @@ xinit(int cols, int rows)
 		xmousebg.blue  = 0x0000;
 	}
 
-	XRecolorCursor(xw.dpy, cursor, &xmousefg, &xmousebg);
+	XRecolorCursor(xw.dpy, xw.vpointer, &xmousefg, &xmousebg);
+	blankpm = XCreateBitmapFromData(xw.dpy, xw.win, &(char){0}, 1, 1);
+	xw.bpointer = XCreatePixmapCursor(xw.dpy, blankpm, blankpm,
+					  &xmousefg, &xmousebg, 0, 0);
 
 	xw.xembed = XInternAtom(xw.dpy, "_XEMBED", False);
 	xw.wmdeletewin = XInternAtom(xw.dpy, "WM_DELETE_WINDOW", False);
@@ -1869,6 +1885,8 @@ unmap(XEvent *ev)
 void
 xsetpointermotion(int set)
 {
+	if (!set && !xw.pointerisvisible)
+		return;
 	MODBIT(xw.attrs.event_mask, set, PointerMotionMask);
 	XChangeWindowAttributes(xw.dpy, xw.win, CWEventMask, &xw.attrs);
 }
@@ -1990,6 +2008,12 @@ kpress(XEvent *ev)
 	Status status;
 	Shortcut *bp;
 
+	if (xw.pointerisvisible) {
+		XDefineCursor(xw.dpy, xw.win, xw.bpointer);
+		xsetpointermotion(1);
+		xw.pointerisvisible = 0;
+	}
+
 	if (IS_SET(MODE_KBDLOCK))
 		return;
 
-- 
2.44.0


From c587dddff1e921eaa948c90a4214b8877ac6903a Mon Sep 17 00:00:00 2001
From: saundersp <pierre.saundersgb@gmail.com>
Date: Sat, 8 Apr 2023 14:05:09 +0200
Subject: [PATCH 12/12] Added fix keyboard input patch

---
 config.def.h | 691 +++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 641 insertions(+), 50 deletions(-)

diff --git a/config.def.h b/config.def.h
index 6f8c504..07be65c 100644
--- a/config.def.h
+++ b/config.def.h
@@ -260,7 +260,80 @@ static Shortcut shortcuts[] = {
  * If you want keys other than the X11 function keys (0xFD00 - 0xFFFF)
  * to be mapped below, add them to this array.
  */
-static KeySym mappedkeys[] = { -1 };
+static KeySym mappedkeys[] = {
+	XK_space,
+	XK_m,
+	XK_i,
+	XK_A,
+	XK_B,
+	XK_C,
+	XK_D,
+	XK_E,
+	XK_F,
+	XK_G,
+	XK_H,
+	XK_I,
+	XK_K,
+	XK_J,
+	XK_L,
+	XK_M,
+	XK_N,
+	XK_O,
+	XK_P,
+	XK_Q,
+	XK_R,
+	XK_S,
+	XK_T,
+	XK_U,
+	XK_V,
+	XK_W,
+	XK_X,
+	XK_Y,
+	XK_Z,
+	XK_Z,
+	XK_0,
+	XK_1,
+	XK_2,
+	XK_3,
+	XK_4,
+	XK_5,
+	XK_6,
+	XK_7,
+	XK_8,
+	XK_9,
+	XK_exclam,
+	XK_quotedbl,
+	XK_numbersign,
+	XK_dollar,
+	XK_percent,
+	XK_ampersand,
+	XK_apostrophe,
+	XK_parenleft,
+	XK_parenright,
+	XK_asterisk,
+	XK_plus,
+	XK_comma,
+	XK_minus,
+	XK_period,
+	XK_slash,
+	XK_colon,
+	XK_semicolon,
+	XK_less,
+	XK_equal,
+	XK_greater,
+	XK_question,
+	XK_at,
+	XK_bracketleft,
+	XK_backslash,
+	XK_bracketright,
+	XK_asciicircum,
+	XK_underscore,
+	XK_grave,
+	XK_braceleft,
+	XK_bar,
+	XK_braceright,
+	XK_asciitilde,
+};
 
 /*
  * State bits to ignore when matching key or button events.  By default,
@@ -276,59 +349,20 @@ static Key key[] = {
 	/* keysym           mask            string      appkey appcursor */
 	{ XK_KP_Home,       ShiftMask,      "\033[2J",       0,   -1},
 	{ XK_KP_Home,       ShiftMask,      "\033[1;2H",     0,   +1},
-	{ XK_KP_Home,       XK_ANY_MOD,     "\033[H",        0,   -1},
-	{ XK_KP_Home,       XK_ANY_MOD,     "\033[1~",       0,   +1},
-	{ XK_KP_Up,         XK_ANY_MOD,     "\033Ox",       +1,    0},
-	{ XK_KP_Up,         XK_ANY_MOD,     "\033[A",        0,   -1},
-	{ XK_KP_Up,         XK_ANY_MOD,     "\033OA",        0,   +1},
-	{ XK_KP_Down,       XK_ANY_MOD,     "\033Or",       +1,    0},
-	{ XK_KP_Down,       XK_ANY_MOD,     "\033[B",        0,   -1},
-	{ XK_KP_Down,       XK_ANY_MOD,     "\033OB",        0,   +1},
-	{ XK_KP_Left,       XK_ANY_MOD,     "\033Ot",       +1,    0},
-	{ XK_KP_Left,       XK_ANY_MOD,     "\033[D",        0,   -1},
-	{ XK_KP_Left,       XK_ANY_MOD,     "\033OD",        0,   +1},
-	{ XK_KP_Right,      XK_ANY_MOD,     "\033Ov",       +1,    0},
-	{ XK_KP_Right,      XK_ANY_MOD,     "\033[C",        0,   -1},
-	{ XK_KP_Right,      XK_ANY_MOD,     "\033OC",        0,   +1},
 	{ XK_KP_Prior,      ShiftMask,      "\033[5;2~",     0,    0},
-	{ XK_KP_Prior,      XK_ANY_MOD,     "\033[5~",       0,    0},
-	{ XK_KP_Begin,      XK_ANY_MOD,     "\033[E",        0,    0},
 	{ XK_KP_End,        ControlMask,    "\033[J",       -1,    0},
 	{ XK_KP_End,        ControlMask,    "\033[1;5F",    +1,    0},
 	{ XK_KP_End,        ShiftMask,      "\033[K",       -1,    0},
 	{ XK_KP_End,        ShiftMask,      "\033[1;2F",    +1,    0},
-	{ XK_KP_End,        XK_ANY_MOD,     "\033[4~",       0,    0},
 	{ XK_KP_Next,       ShiftMask,      "\033[6;2~",     0,    0},
-	{ XK_KP_Next,       XK_ANY_MOD,     "\033[6~",       0,    0},
 	{ XK_KP_Insert,     ShiftMask,      "\033[2;2~",    +1,    0},
 	{ XK_KP_Insert,     ShiftMask,      "\033[4l",      -1,    0},
 	{ XK_KP_Insert,     ControlMask,    "\033[L",       -1,    0},
 	{ XK_KP_Insert,     ControlMask,    "\033[2;5~",    +1,    0},
-	{ XK_KP_Insert,     XK_ANY_MOD,     "\033[4h",      -1,    0},
-	{ XK_KP_Insert,     XK_ANY_MOD,     "\033[2~",      +1,    0},
 	{ XK_KP_Delete,     ControlMask,    "\033[M",       -1,    0},
 	{ XK_KP_Delete,     ControlMask,    "\033[3;5~",    +1,    0},
 	{ XK_KP_Delete,     ShiftMask,      "\033[2K",      -1,    0},
 	{ XK_KP_Delete,     ShiftMask,      "\033[3;2~",    +1,    0},
-	{ XK_KP_Delete,     XK_ANY_MOD,     "\033[P",       -1,    0},
-	{ XK_KP_Delete,     XK_ANY_MOD,     "\033[3~",      +1,    0},
-	{ XK_KP_Multiply,   XK_ANY_MOD,     "\033Oj",       +2,    0},
-	{ XK_KP_Add,        XK_ANY_MOD,     "\033Ok",       +2,    0},
-	{ XK_KP_Enter,      XK_ANY_MOD,     "\033OM",       +2,    0},
-	{ XK_KP_Enter,      XK_ANY_MOD,     "\r",           -1,    0},
-	{ XK_KP_Subtract,   XK_ANY_MOD,     "\033Om",       +2,    0},
-	{ XK_KP_Decimal,    XK_ANY_MOD,     "\033On",       +2,    0},
-	{ XK_KP_Divide,     XK_ANY_MOD,     "\033Oo",       +2,    0},
-	{ XK_KP_0,          XK_ANY_MOD,     "\033Op",       +2,    0},
-	{ XK_KP_1,          XK_ANY_MOD,     "\033Oq",       +2,    0},
-	{ XK_KP_2,          XK_ANY_MOD,     "\033Or",       +2,    0},
-	{ XK_KP_3,          XK_ANY_MOD,     "\033Os",       +2,    0},
-	{ XK_KP_4,          XK_ANY_MOD,     "\033Ot",       +2,    0},
-	{ XK_KP_5,          XK_ANY_MOD,     "\033Ou",       +2,    0},
-	{ XK_KP_6,          XK_ANY_MOD,     "\033Ov",       +2,    0},
-	{ XK_KP_7,          XK_ANY_MOD,     "\033Ow",       +2,    0},
-	{ XK_KP_8,          XK_ANY_MOD,     "\033Ox",       +2,    0},
-	{ XK_KP_9,          XK_ANY_MOD,     "\033Oy",       +2,    0},
 	{ XK_Up,            ShiftMask,      "\033[1;2A",     0,    0},
 	{ XK_Up,            Mod1Mask,       "\033[1;3A",     0,    0},
 	{ XK_Up,         ShiftMask|Mod1Mask,"\033[1;4A",     0,    0},
@@ -367,36 +401,27 @@ static Key key[] = {
 	{ XK_Right,         XK_ANY_MOD,     "\033OC",        0,   +1},
 	{ XK_ISO_Left_Tab,  ShiftMask,      "\033[Z",        0,    0},
 	{ XK_Return,        Mod1Mask,       "\033\r",        0,    0},
-	{ XK_Return,        XK_ANY_MOD,     "\r",            0,    0},
+	{ XK_Return,        XK_NO_MOD,      "\r",            0,    0},
 	{ XK_Insert,        ShiftMask,      "\033[4l",      -1,    0},
 	{ XK_Insert,        ShiftMask,      "\033[2;2~",    +1,    0},
 	{ XK_Insert,        ControlMask,    "\033[L",       -1,    0},
 	{ XK_Insert,        ControlMask,    "\033[2;5~",    +1,    0},
-	{ XK_Insert,        XK_ANY_MOD,     "\033[4h",      -1,    0},
-	{ XK_Insert,        XK_ANY_MOD,     "\033[2~",      +1,    0},
 	{ XK_Delete,        ControlMask,    "\033[M",       -1,    0},
 	{ XK_Delete,        ControlMask,    "\033[3;5~",    +1,    0},
 	{ XK_Delete,        ShiftMask,      "\033[2K",      -1,    0},
 	{ XK_Delete,        ShiftMask,      "\033[3;2~",    +1,    0},
-	{ XK_Delete,        XK_ANY_MOD,     "\033[P",       -1,    0},
-	{ XK_Delete,        XK_ANY_MOD,     "\033[3~",      +1,    0},
 	{ XK_BackSpace,     XK_NO_MOD,      "\177",          0,    0},
 	{ XK_BackSpace,     Mod1Mask,       "\033\177",      0,    0},
 	{ XK_Home,          ShiftMask,      "\033[2J",       0,   -1},
 	{ XK_Home,          ShiftMask,      "\033[1;2H",     0,   +1},
-	{ XK_Home,          XK_ANY_MOD,     "\033[H",        0,   -1},
-	{ XK_Home,          XK_ANY_MOD,     "\033[1~",       0,   +1},
 	{ XK_End,           ControlMask,    "\033[J",       -1,    0},
 	{ XK_End,           ControlMask,    "\033[1;5F",    +1,    0},
 	{ XK_End,           ShiftMask,      "\033[K",       -1,    0},
 	{ XK_End,           ShiftMask,      "\033[1;2F",    +1,    0},
-	{ XK_End,           XK_ANY_MOD,     "\033[4~",       0,    0},
 	{ XK_Prior,         ControlMask,    "\033[5;5~",     0,    0},
 	{ XK_Prior,         ShiftMask,      "\033[5;2~",     0,    0},
-	{ XK_Prior,         XK_ANY_MOD,     "\033[5~",       0,    0},
 	{ XK_Next,          ControlMask,    "\033[6;5~",     0,    0},
 	{ XK_Next,          ShiftMask,      "\033[6;2~",     0,    0},
-	{ XK_Next,          XK_ANY_MOD,     "\033[6~",       0,    0},
 	{ XK_F1,            XK_NO_MOD,      "\033OP" ,       0,    0},
 	{ XK_F1, /* F13 */  ShiftMask,      "\033[1;2P",     0,    0},
 	{ XK_F1, /* F25 */  ControlMask,    "\033[1;5P",     0,    0},
@@ -483,6 +508,572 @@ static Key key[] = {
 	{ XK_F33,           XK_NO_MOD,      "\033[20;5~",    0,    0},
 	{ XK_F34,           XK_NO_MOD,      "\033[21;5~",    0,    0},
 	{ XK_F35,           XK_NO_MOD,      "\033[23;5~",    0,    0},
+
+	// libtermkey compatible keyboard input
+	{ XK_KP_Home,      XK_NO_MOD,                      "\033[H",      0, -1},
+	{ XK_KP_Home,      XK_NO_MOD,                      "\033[1~",     0, +1},
+	{ XK_KP_Home,      ControlMask,                    "\033[149;5u", 0,  0},
+	{ XK_KP_Home,      ControlMask|ShiftMask,          "\033[149;6u", 0,  0},
+	{ XK_KP_Home,      Mod1Mask,                       "\033[149;3u", 0,  0},
+	{ XK_KP_Home,      Mod1Mask|ControlMask,           "\033[149;7u", 0,  0},
+	{ XK_KP_Home,      Mod1Mask|ControlMask|ShiftMask, "\033[149;8u", 0,  0},
+	{ XK_KP_Home,      Mod1Mask|ShiftMask,             "\033[149;4u", 0,  0},
+	{ XK_KP_Home,      ShiftMask,                      "\033[149;2u", 0,  0},
+	{ XK_KP_Up,        XK_NO_MOD,                      "\033Ox",     +1,  0},
+	{ XK_KP_Up,        XK_NO_MOD,                      "\033[A",      0, -1},
+	{ XK_KP_Up,        XK_NO_MOD,                      "\033OA",      0, +1},
+	{ XK_KP_Up,        ControlMask,                    "\033[151;5u", 0,  0},
+	{ XK_KP_Up,        ControlMask|ShiftMask,          "\033[151;6u", 0,  0},
+	{ XK_KP_Up,        Mod1Mask,                       "\033[151;3u", 0,  0},
+	{ XK_KP_Up,        Mod1Mask|ControlMask,           "\033[151;7u", 0,  0},
+	{ XK_KP_Up,        Mod1Mask|ControlMask|ShiftMask, "\033[151;8u", 0,  0},
+	{ XK_KP_Up,        Mod1Mask|ShiftMask,             "\033[151;4u", 0,  0},
+	{ XK_KP_Up,        ShiftMask,                      "\033[151;2u", 0,  0},
+	{ XK_KP_Down,      XK_NO_MOD,                      "\033Or",     +1,  0},
+	{ XK_KP_Down,      XK_NO_MOD,                      "\033[B",      0, -1},
+	{ XK_KP_Down,      XK_NO_MOD,                      "\033OB",      0, +1},
+	{ XK_KP_Down,      ControlMask,                    "\033[153;5u", 0,  0},
+	{ XK_KP_Down,      ControlMask|ShiftMask,          "\033[153;6u", 0,  0},
+	{ XK_KP_Down,      Mod1Mask,                       "\033[153;3u", 0,  0},
+	{ XK_KP_Down,      Mod1Mask|ControlMask,           "\033[153;7u", 0,  0},
+	{ XK_KP_Down,      Mod1Mask|ControlMask|ShiftMask, "\033[153;8u", 0,  0},
+	{ XK_KP_Down,      Mod1Mask|ShiftMask,             "\033[153;4u", 0,  0},
+	{ XK_KP_Down,      ShiftMask,                      "\033[153;2u", 0,  0},
+	{ XK_KP_Left,      XK_NO_MOD,                      "\033Ot",     +1,  0},
+	{ XK_KP_Left,      XK_NO_MOD,                      "\033[D",      0, -1},
+	{ XK_KP_Left,      XK_NO_MOD,                      "\033OD",      0, +1},
+	{ XK_KP_Left,      ControlMask,                    "\033[150;5u", 0,  0},
+	{ XK_KP_Left,      ControlMask|ShiftMask,          "\033[150;6u", 0,  0},
+	{ XK_KP_Left,      Mod1Mask,                       "\033[150;3u", 0,  0},
+	{ XK_KP_Left,      Mod1Mask|ControlMask,           "\033[150;7u", 0,  0},
+	{ XK_KP_Left,      Mod1Mask|ControlMask|ShiftMask, "\033[150;8u", 0,  0},
+	{ XK_KP_Left,      Mod1Mask|ShiftMask,             "\033[150;4u", 0,  0},
+	{ XK_KP_Left,      ShiftMask,                      "\033[150;2u", 0,  0},
+	{ XK_KP_Right,     XK_NO_MOD,                      "\033Ov",     +1,  0},
+	{ XK_KP_Right,     XK_NO_MOD,                      "\033[C",      0, -1},
+	{ XK_KP_Right,     XK_NO_MOD,                      "\033OC",      0, +1},
+	{ XK_KP_Right,     ControlMask,                    "\033[152;5u", 0,  0},
+	{ XK_KP_Right,     ControlMask|ShiftMask,          "\033[152;6u", 0,  0},
+	{ XK_KP_Right,     Mod1Mask,                       "\033[152;3u", 0,  0},
+	{ XK_KP_Right,     Mod1Mask|ControlMask,           "\033[152;7u", 0,  0},
+	{ XK_KP_Right,     Mod1Mask|ControlMask|ShiftMask, "\033[152;8u", 0,  0},
+	{ XK_KP_Right,     Mod1Mask|ShiftMask,             "\033[152;4u", 0,  0},
+	{ XK_KP_Right,     ShiftMask,                      "\033[152;2u", 0,  0},
+	{ XK_KP_Prior,     XK_NO_MOD,                      "\033[5~",     0,  0},
+	{ XK_KP_Prior,     ControlMask,                    "\033[154;5u", 0,  0},
+	{ XK_KP_Prior,     ControlMask|ShiftMask,          "\033[154;6u", 0,  0},
+	{ XK_KP_Prior,     Mod1Mask,                       "\033[154;3u", 0,  0},
+	{ XK_KP_Prior,     Mod1Mask|ControlMask,           "\033[154;7u", 0,  0},
+	{ XK_KP_Prior,     Mod1Mask|ControlMask|ShiftMask, "\033[154;8u", 0,  0},
+	{ XK_KP_Prior,     Mod1Mask|ShiftMask,             "\033[154;4u", 0,  0},
+	{ XK_KP_Begin,     XK_NO_MOD,                      "\033[E",      0,  0},
+	{ XK_KP_Begin,     ControlMask,                    "\033[157;5u", 0,  0},
+	{ XK_KP_Begin,     ControlMask|ShiftMask,          "\033[157;6u", 0,  0},
+	{ XK_KP_Begin,     Mod1Mask,                       "\033[157;3u", 0,  0},
+	{ XK_KP_Begin,     Mod1Mask|ControlMask,           "\033[157;7u", 0,  0},
+	{ XK_KP_Begin,     Mod1Mask|ControlMask|ShiftMask, "\033[157;8u", 0,  0},
+	{ XK_KP_Begin,     Mod1Mask|ShiftMask,             "\033[157;4u", 0,  0},
+	{ XK_KP_Begin,     ShiftMask,                      "\033[157;2u", 0,  0},
+	{ XK_KP_End,       XK_NO_MOD,                      "\033[4~",     0,  0},
+	{ XK_KP_End,       ControlMask|ShiftMask,          "\033[156;6u", 0,  0},
+	{ XK_KP_End,       Mod1Mask,                       "\033[156;3u", 0,  0},
+	{ XK_KP_End,       Mod1Mask|ControlMask,           "\033[156;7u", 0,  0},
+	{ XK_KP_End,       Mod1Mask|ControlMask|ShiftMask, "\033[156;8u", 0,  0},
+	{ XK_KP_End,       Mod1Mask|ShiftMask,             "\033[156;4u", 0,  0},
+	{ XK_KP_Next,      XK_NO_MOD,                      "\033[6~",     0,  0},
+	{ XK_KP_Next,      ControlMask,                    "\033[155;5u", 0,  0},
+	{ XK_KP_Next,      ControlMask|ShiftMask,          "\033[155;6u", 0,  0},
+	{ XK_KP_Next,      Mod1Mask,                       "\033[155;3u", 0,  0},
+	{ XK_KP_Next,      Mod1Mask|ControlMask,           "\033[155;7u", 0,  0},
+	{ XK_KP_Next,      Mod1Mask|ControlMask|ShiftMask, "\033[155;8u", 0,  0},
+	{ XK_KP_Next,      Mod1Mask|ShiftMask,             "\033[155;4u", 0,  0},
+	{ XK_KP_Insert,    XK_NO_MOD,                      "\033[4h",    -1,  0},
+	{ XK_KP_Insert,    XK_NO_MOD,                      "\033[2~",    +1,  0},
+	{ XK_KP_Insert,    ControlMask|ShiftMask,          "\033[158;6u", 0,  0},
+	{ XK_KP_Insert,    Mod1Mask,                       "\033[158;3u", 0,  0},
+	{ XK_KP_Insert,    Mod1Mask|ControlMask,           "\033[158;7u", 0,  0},
+	{ XK_KP_Insert,    Mod1Mask|ControlMask|ShiftMask, "\033[158;8u", 0,  0},
+	{ XK_KP_Insert,    Mod1Mask|ShiftMask,             "\033[158;4u", 0,  0},
+	{ XK_KP_Delete,    XK_NO_MOD,                      "\033[P",     -1,  0},
+	{ XK_KP_Delete,    XK_NO_MOD,                      "\033[3~",    +1,  0},
+	{ XK_KP_Delete,    ControlMask|ShiftMask,          "\033[159;6u", 0,  0},
+	{ XK_KP_Delete,    Mod1Mask,                       "\033[159;3u", 0,  0},
+	{ XK_KP_Delete,    Mod1Mask|ControlMask,           "\033[159;7u", 0,  0},
+	{ XK_KP_Delete,    Mod1Mask|ControlMask|ShiftMask, "\033[159;8u", 0,  0},
+	{ XK_KP_Delete,    Mod1Mask|ShiftMask,             "\033[159;4u", 0,  0},
+	{ XK_KP_Multiply,  XK_NO_MOD,                      "\033Oj",     +2,  0},
+	{ XK_KP_Multiply,  ControlMask,                    "\033[170;5u", 0,  0},
+	{ XK_KP_Multiply,  ControlMask|ShiftMask,          "\033[170;6u", 0,  0},
+	{ XK_KP_Multiply,  Mod1Mask,                       "\033[170;3u", 0,  0},
+	{ XK_KP_Multiply,  Mod1Mask|ControlMask,           "\033[170;7u", 0,  0},
+	{ XK_KP_Multiply,  Mod1Mask|ControlMask|ShiftMask, "\033[170;8u", 0,  0},
+	{ XK_KP_Multiply,  Mod1Mask|ShiftMask,             "\033[170;4u", 0,  0},
+	{ XK_KP_Multiply,  ShiftMask,                      "\033[170;2u", 0,  0},
+	{ XK_KP_Add,       XK_NO_MOD,                      "\033Ok",     +2,  0},
+	{ XK_KP_Add,       ControlMask,                    "\033[171;5u", 0,  0},
+	{ XK_KP_Add,       ControlMask|ShiftMask,          "\033[171;6u", 0,  0},
+	{ XK_KP_Add,       Mod1Mask,                       "\033[171;3u", 0,  0},
+	{ XK_KP_Add,       Mod1Mask|ControlMask,           "\033[171;7u", 0,  0},
+	{ XK_KP_Add,       Mod1Mask|ControlMask|ShiftMask, "\033[171;8u", 0,  0},
+	{ XK_KP_Add,       Mod1Mask|ShiftMask,             "\033[171;4u", 0,  0},
+	{ XK_KP_Add,       ShiftMask,                      "\033[171;2u", 0,  0},
+	{ XK_KP_Enter,     XK_NO_MOD,                      "\033OM",     +2,  0},
+	{ XK_KP_Enter,     XK_NO_MOD,                      "\r",         -1,  0},
+	{ XK_KP_Enter,     XK_NO_MOD,                      "\r\n",       -1,  0},
+	{ XK_KP_Enter,     ControlMask,                    "\033[141;5u", 0,  0},
+	{ XK_KP_Enter,     ControlMask|ShiftMask,          "\033[141;6u", 0,  0},
+	{ XK_KP_Enter,     Mod1Mask,                       "\033[141;3u", 0,  0},
+	{ XK_KP_Enter,     Mod1Mask|ControlMask,           "\033[141;7u", 0,  0},
+	{ XK_KP_Enter,     Mod1Mask|ControlMask|ShiftMask, "\033[141;8u", 0,  0},
+	{ XK_KP_Enter,     Mod1Mask|ShiftMask,             "\033[141;4u", 0,  0},
+	{ XK_KP_Enter,     ShiftMask,                      "\033[141;2u", 0,  0},
+	{ XK_KP_Subtract,  XK_NO_MOD,                      "\033Om",     +2,  0},
+	{ XK_KP_Subtract,  ControlMask,                    "\033[173;5u", 0,  0},
+	{ XK_KP_Subtract,  ControlMask|ShiftMask,          "\033[173;6u", 0,  0},
+	{ XK_KP_Subtract,  Mod1Mask,                       "\033[173;3u", 0,  0},
+	{ XK_KP_Subtract,  Mod1Mask|ControlMask,           "\033[173;7u", 0,  0},
+	{ XK_KP_Subtract,  Mod1Mask|ControlMask|ShiftMask, "\033[173;8u", 0,  0},
+	{ XK_KP_Subtract,  Mod1Mask|ShiftMask,             "\033[173;4u", 0,  0},
+	{ XK_KP_Subtract,  ShiftMask,                      "\033[173;2u", 0,  0},
+	{ XK_KP_Decimal,   XK_NO_MOD,                      "\033On",     +2,  0},
+	{ XK_KP_Decimal,   ControlMask,                    "\033[174;5u", 0,  0},
+	{ XK_KP_Decimal,   ControlMask|ShiftMask,          "\033[174;6u", 0,  0},
+	{ XK_KP_Decimal,   Mod1Mask,                       "\033[174;3u", 0,  0},
+	{ XK_KP_Decimal,   Mod1Mask|ControlMask,           "\033[174;7u", 0,  0},
+	{ XK_KP_Decimal,   Mod1Mask|ControlMask|ShiftMask, "\033[174;8u", 0,  0},
+	{ XK_KP_Decimal,   Mod1Mask|ShiftMask,             "\033[174;4u", 0,  0},
+	{ XK_KP_Decimal,   ShiftMask,                      "\033[174;2u", 0,  0},
+	{ XK_KP_Divide,    XK_NO_MOD,                      "\033Oo",     +2,  0},
+	{ XK_KP_Divide,    ControlMask,                    "\033[175;5u", 0,  0},
+	{ XK_KP_Divide,    ControlMask|ShiftMask,          "\033[175;6u", 0,  0},
+	{ XK_KP_Divide,    Mod1Mask,                       "\033[175;3u", 0,  0},
+	{ XK_KP_Divide,    Mod1Mask|ControlMask,           "\033[175;7u", 0,  0},
+	{ XK_KP_Divide,    Mod1Mask|ControlMask|ShiftMask, "\033[175;8u", 0,  0},
+	{ XK_KP_Divide,    Mod1Mask|ShiftMask,             "\033[175;4u", 0,  0},
+	{ XK_KP_Divide,    ShiftMask,                      "\033[175;2u", 0,  0},
+	{ XK_KP_0,         XK_NO_MOD,                      "\033Op",     +2,  0},
+	{ XK_KP_0,         ControlMask,                    "\033[176;5u", 0,  0},
+	{ XK_KP_0,         ControlMask|ShiftMask,          "\033[176;6u", 0,  0},
+	{ XK_KP_0,         Mod1Mask,                       "\033[176;3u", 0,  0},
+	{ XK_KP_0,         Mod1Mask|ControlMask,           "\033[176;7u", 0,  0},
+	{ XK_KP_0,         Mod1Mask|ControlMask|ShiftMask, "\033[176;8u", 0,  0},
+	{ XK_KP_0,         Mod1Mask|ShiftMask,             "\033[176;4u", 0,  0},
+	{ XK_KP_0,         ShiftMask,                      "\033[176;2u", 0,  0},
+	{ XK_KP_1,         XK_NO_MOD,                      "\033Oq",     +2,  0},
+	{ XK_KP_0,         ControlMask,                    "\033[177;5u", 0,  0},
+	{ XK_KP_0,         ControlMask|ShiftMask,          "\033[177;6u", 0,  0},
+	{ XK_KP_0,         Mod1Mask,                       "\033[177;3u", 0,  0},
+	{ XK_KP_0,         Mod1Mask|ControlMask,           "\033[177;7u", 0,  0},
+	{ XK_KP_0,         Mod1Mask|ControlMask|ShiftMask, "\033[177;8u", 0,  0},
+	{ XK_KP_0,         Mod1Mask|ShiftMask,             "\033[177;4u", 0,  0},
+	{ XK_KP_0,         ShiftMask,                      "\033[177;2u", 0,  0},
+	{ XK_KP_2,         XK_NO_MOD,                      "\033Or",     +2,  0},
+	{ XK_KP_2,         ControlMask,                    "\033[178;5u", 0,  0},
+	{ XK_KP_2,         ControlMask|ShiftMask,          "\033[178;6u", 0,  0},
+	{ XK_KP_2,         Mod1Mask,                       "\033[178;3u", 0,  0},
+	{ XK_KP_2,         Mod1Mask|ControlMask,           "\033[178;7u", 0,  0},
+	{ XK_KP_2,         Mod1Mask|ControlMask|ShiftMask, "\033[178;8u", 0,  0},
+	{ XK_KP_2,         Mod1Mask|ShiftMask,             "\033[178;4u", 0,  0},
+	{ XK_KP_2,         ShiftMask,                      "\033[178;2u", 0,  0},
+	{ XK_KP_3,         XK_NO_MOD,                      "\033Os",     +2,  0},
+	{ XK_KP_3,         ControlMask,                    "\033[179;5u", 0,  0},
+	{ XK_KP_3,         ControlMask|ShiftMask,          "\033[179;6u", 0,  0},
+	{ XK_KP_3,         Mod1Mask,                       "\033[179;3u", 0,  0},
+	{ XK_KP_3,         Mod1Mask|ControlMask,           "\033[179;7u", 0,  0},
+	{ XK_KP_3,         Mod1Mask|ControlMask|ShiftMask, "\033[179;8u", 0,  0},
+	{ XK_KP_3,         Mod1Mask|ShiftMask,             "\033[179;4u", 0,  0},
+	{ XK_KP_3,         ShiftMask,                      "\033[179;2u", 0,  0},
+	{ XK_KP_4,         XK_NO_MOD,                      "\033Ot",     +2,  0},
+	{ XK_KP_4,         ControlMask,                    "\033[180;5u", 0,  0},
+	{ XK_KP_4,         ControlMask|ShiftMask,          "\033[180;6u", 0,  0},
+	{ XK_KP_4,         Mod1Mask,                       "\033[180;3u", 0,  0},
+	{ XK_KP_4,         Mod1Mask|ControlMask,           "\033[180;7u", 0,  0},
+	{ XK_KP_4,         Mod1Mask|ControlMask|ShiftMask, "\033[180;8u", 0,  0},
+	{ XK_KP_4,         Mod1Mask|ShiftMask,             "\033[180;4u", 0,  0},
+	{ XK_KP_4,         ShiftMask,                      "\033[180;2u", 0,  0},
+	{ XK_KP_5,         XK_NO_MOD,                      "\033Ou",     +2,  0},
+	{ XK_KP_5,         ControlMask,                    "\033[181;5u", 0,  0},
+	{ XK_KP_5,         ControlMask|ShiftMask,          "\033[181;6u", 0,  0},
+	{ XK_KP_5,         Mod1Mask,                       "\033[181;3u", 0,  0},
+	{ XK_KP_5,         Mod1Mask|ControlMask,           "\033[181;7u", 0,  0},
+	{ XK_KP_5,         Mod1Mask|ControlMask|ShiftMask, "\033[181;8u", 0,  0},
+	{ XK_KP_5,         Mod1Mask|ShiftMask,             "\033[181;4u", 0,  0},
+	{ XK_KP_5,         ShiftMask,                      "\033[181;2u", 0,  0},
+	{ XK_KP_6,         XK_NO_MOD,                      "\033Ov",     +2,  0},
+	{ XK_KP_6,         ControlMask,                    "\033[182;5u", 0,  0},
+	{ XK_KP_6,         ControlMask|ShiftMask,          "\033[182;6u", 0,  0},
+	{ XK_KP_6,         Mod1Mask,                       "\033[182;3u", 0,  0},
+	{ XK_KP_6,         Mod1Mask|ControlMask,           "\033[182;7u", 0,  0},
+	{ XK_KP_6,         Mod1Mask|ControlMask|ShiftMask, "\033[182;8u", 0,  0},
+	{ XK_KP_6,         Mod1Mask|ShiftMask,             "\033[182;4u", 0,  0},
+	{ XK_KP_6,         ShiftMask,                      "\033[182;2u", 0,  0},
+	{ XK_KP_7,         XK_NO_MOD,                      "\033Ow",     +2,  0},
+	{ XK_KP_7,         ControlMask,                    "\033[183;5u", 0,  0},
+	{ XK_KP_7,         ControlMask|ShiftMask,          "\033[183;6u", 0,  0},
+	{ XK_KP_7,         Mod1Mask,                       "\033[183;3u", 0,  0},
+	{ XK_KP_7,         Mod1Mask|ControlMask,           "\033[183;7u", 0,  0},
+	{ XK_KP_7,         Mod1Mask|ControlMask|ShiftMask, "\033[183;8u", 0,  0},
+	{ XK_KP_7,         Mod1Mask|ShiftMask,             "\033[183;4u", 0,  0},
+	{ XK_KP_7,         ShiftMask,                      "\033[183;2u", 0,  0},
+	{ XK_KP_8,         XK_NO_MOD,                      "\033Ox",     +2,  0},
+	{ XK_KP_8,         ControlMask,                    "\033[184;5u", 0,  0},
+	{ XK_KP_8,         ControlMask|ShiftMask,          "\033[184;6u", 0,  0},
+	{ XK_KP_8,         Mod1Mask,                       "\033[184;3u", 0,  0},
+	{ XK_KP_8,         Mod1Mask|ControlMask,           "\033[184;7u", 0,  0},
+	{ XK_KP_8,         Mod1Mask|ControlMask|ShiftMask, "\033[184;8u", 0,  0},
+	{ XK_KP_8,         Mod1Mask|ShiftMask,             "\033[184;4u", 0,  0},
+	{ XK_KP_8,         ShiftMask,                      "\033[184;2u", 0,  0},
+	{ XK_KP_9,         XK_NO_MOD,                      "\033Oy",     +2,  0},
+	{ XK_KP_9,         ControlMask,                    "\033[185;5u", 0,  0},
+	{ XK_KP_9,         ControlMask|ShiftMask,          "\033[185;6u", 0,  0},
+	{ XK_KP_9,         Mod1Mask,                       "\033[185;3u", 0,  0},
+	{ XK_KP_9,         Mod1Mask|ControlMask,           "\033[185;7u", 0,  0},
+	{ XK_KP_9,         Mod1Mask|ControlMask|ShiftMask, "\033[185;8u", 0,  0},
+	{ XK_KP_9,         Mod1Mask|ShiftMask,             "\033[185;4u", 0,  0},
+	{ XK_KP_9,         ShiftMask,                      "\033[185;2u", 0,  0},
+	{ XK_BackSpace,    ControlMask,                    "\033[127;5u", 0,  0},
+	{ XK_BackSpace,    ControlMask|ShiftMask,          "\033[127;6u", 0,  0},
+	{ XK_BackSpace,    Mod1Mask,                       "\033[127;3u", 0,  0},
+	{ XK_BackSpace,    Mod1Mask|ControlMask,           "\033[127;7u", 0,  0},
+	{ XK_BackSpace,    Mod1Mask|ControlMask|ShiftMask, "\033[127;8u", 0,  0},
+	{ XK_BackSpace,    Mod1Mask|ShiftMask,             "\033[127;4u", 0,  0},
+	{ XK_BackSpace,    ShiftMask,                      "\033[127;2u", 0,  0},
+	{ XK_Tab,          ControlMask,                    "\033[9;5u",   0,  0},
+	{ XK_Tab,          ControlMask|ShiftMask,          "\033[1;5Z",   0,  0},
+	{ XK_Tab,          Mod1Mask,                       "\033[1;3Z",   0,  0},
+	{ XK_Tab,          Mod1Mask|ControlMask,           "\033[1;7Z",   0,  0},
+	{ XK_Tab,          Mod1Mask|ControlMask|ShiftMask, "\033[1;8Z",   0,  0},
+	{ XK_Tab,          Mod1Mask|ShiftMask,             "\033[1;4Z",   0,  0},
+	{ XK_Return,       ControlMask,                    "\033[13;5u",  0,  0},
+	{ XK_Return,       ControlMask|ShiftMask,          "\033[13;6u",  0,  0},
+	{ XK_Return,       Mod1Mask,                       "\033[13;3u",  0,  0},
+	{ XK_Return,       Mod1Mask|ControlMask,           "\033[13;7u",  0,  0},
+	{ XK_Return,       Mod1Mask|ControlMask|ShiftMask, "\033[13;8u",  0,  0},
+	{ XK_Return,       Mod1Mask|ShiftMask,             "\033[13;4u",  0,  0},
+	{ XK_Return,       ShiftMask,                      "\033[13;2u",  0,  0},
+	{ XK_Pause,        ControlMask,                    "\033[18;5u",  0,  0},
+	{ XK_Pause,        ControlMask|ShiftMask,          "\033[18;6u",  0,  0},
+	{ XK_Pause,        Mod1Mask,                       "\033[18;3u",  0,  0},
+	{ XK_Pause,        Mod1Mask|ControlMask,           "\033[18;7u",  0,  0},
+	{ XK_Pause,        Mod1Mask|ControlMask|ShiftMask, "\033[18;8u",  0,  0},
+	{ XK_Pause,        Mod1Mask|ShiftMask,             "\033[18;4u",  0,  0},
+	{ XK_Pause,        ShiftMask,                      "\033[18;2u",  0,  0},
+	{ XK_Scroll_Lock,  ControlMask,                    "\033[20;5u",  0,  0},
+	{ XK_Scroll_Lock,  ControlMask|ShiftMask,          "\033[20;6u",  0,  0},
+	{ XK_Scroll_Lock,  Mod1Mask,                       "\033[20;3u",  0,  0},
+	{ XK_Scroll_Lock,  Mod1Mask|ControlMask,           "\033[20;7u",  0,  0},
+	{ XK_Scroll_Lock,  Mod1Mask|ControlMask|ShiftMask, "\033[20;8u",  0,  0},
+	{ XK_Scroll_Lock,  Mod1Mask|ShiftMask,             "\033[20;4u",  0,  0},
+	{ XK_Scroll_Lock,  ShiftMask,                      "\033[20;2u",  0,  0},
+	{ XK_Escape,       ControlMask,                    "\033[27;5u",  0,  0},
+	{ XK_Escape,       ControlMask|ShiftMask,          "\033[27;6u",  0,  0},
+	{ XK_Escape,       Mod1Mask,                       "\033[27;3u",  0,  0},
+	{ XK_Escape,       Mod1Mask|ControlMask,           "\033[27;7u",  0,  0},
+	{ XK_Escape,       Mod1Mask|ControlMask|ShiftMask, "\033[27;8u",  0,  0},
+	{ XK_Escape,       Mod1Mask|ShiftMask,             "\033[27;4u",  0,  0},
+	{ XK_Escape,       ShiftMask,                      "\033[27;2u",  0,  0},
+	{ XK_Home,         XK_NO_MOD,                      "\033[H",      0, -1},
+	{ XK_Home,         XK_NO_MOD,                      "\033[1~",     0, +1},
+	{ XK_Home,         ControlMask|ShiftMask,          "\033[80;6u",  0,  0},
+	{ XK_Home,         Mod1Mask,                       "\033[80;3u",  0,  0},
+	{ XK_Home,         Mod1Mask|ControlMask,           "\033[80;7u",  0,  0},
+	{ XK_Home,         Mod1Mask|ControlMask|ShiftMask, "\033[80;8u",  0,  0},
+	{ XK_Home,         Mod1Mask|ShiftMask,             "\033[80;4u",  0,  0},
+	{ XK_End,          XK_NO_MOD,                      "\033[4~",     0,  0},
+	{ XK_End,          ControlMask|ShiftMask,          "\033[87;6u",  0,  0},
+	{ XK_End,          Mod1Mask,                       "\033[87;3u",  0,  0},
+	{ XK_End,          Mod1Mask|ControlMask,           "\033[87;7u",  0,  0},
+	{ XK_End,          Mod1Mask|ControlMask|ShiftMask, "\033[87;8u",  0,  0},
+	{ XK_End,          Mod1Mask|ShiftMask,             "\033[87;4u",  0,  0},
+	{ XK_Prior,        XK_NO_MOD,                      "\033[5~",     0,  0},
+	{ XK_Prior,        ControlMask|ShiftMask,          "\033[85;6u",  0,  0},
+	{ XK_Prior,        Mod1Mask,                       "\033[85;3u",  0,  0},
+	{ XK_Prior,        Mod1Mask|ControlMask,           "\033[85;7u",  0,  0},
+	{ XK_Prior,        Mod1Mask|ControlMask|ShiftMask, "\033[85;8u",  0,  0},
+	{ XK_Prior,        Mod1Mask|ShiftMask,             "\033[85;4u",  0,  0},
+	{ XK_Next,         XK_NO_MOD,                      "\033[6~",     0,  0},
+	{ XK_Next,         ControlMask|ShiftMask,          "\033[86;6u",  0,  0},
+	{ XK_Next,         Mod1Mask,                       "\033[86;3u",  0,  0},
+	{ XK_Next,         Mod1Mask|ControlMask,           "\033[86;7u",  0,  0},
+	{ XK_Next,         Mod1Mask|ControlMask|ShiftMask, "\033[86;8u",  0,  0},
+	{ XK_Next,         Mod1Mask|ShiftMask,             "\033[86;4u",  0,  0},
+	{ XK_Print,        ControlMask,                    "\033[97;5u",  0,  0},
+	{ XK_Print,        ControlMask|ShiftMask,          "\033[97;6u",  0,  0},
+	{ XK_Print,        Mod1Mask,                       "\033[97;3u",  0,  0},
+	{ XK_Print,        Mod1Mask|ControlMask,           "\033[97;7u",  0,  0},
+	{ XK_Print,        Mod1Mask|ControlMask|ShiftMask, "\033[97;8u",  0,  0},
+	{ XK_Print,        Mod1Mask|ShiftMask,             "\033[97;4u",  0,  0},
+	{ XK_Print,        ShiftMask,                      "\033[97;2u",  0,  0},
+	{ XK_Insert,       XK_NO_MOD,                      "\033[4h",    -1,  0},
+	{ XK_Insert,       XK_NO_MOD,                      "\033[2~",    +1,  0},
+	{ XK_Insert,       ControlMask|ShiftMask,          "\033[99;6u",  0,  0},
+	{ XK_Insert,       Mod1Mask,                       "\033[99;3u",  0,  0},
+	{ XK_Insert,       Mod1Mask|ControlMask,           "\033[99;7u",  0,  0},
+	{ XK_Insert,       Mod1Mask|ControlMask|ShiftMask, "\033[99;8u",  0,  0},
+	{ XK_Insert,       Mod1Mask|ShiftMask,             "\033[99;4u",  0,  0},
+	{ XK_Menu,         ControlMask,                    "\033[103;5u", 0,  0},
+	{ XK_Menu,         ControlMask|ShiftMask,          "\033[103;6u", 0,  0},
+	{ XK_Menu,         Mod1Mask,                       "\033[103;3u", 0,  0},
+	{ XK_Menu,         Mod1Mask|ControlMask,           "\033[103;7u", 0,  0},
+	{ XK_Menu,         Mod1Mask|ControlMask|ShiftMask, "\033[103;8u", 0,  0},
+	{ XK_Menu,         Mod1Mask|ShiftMask,             "\033[103;4u", 0,  0},
+	{ XK_Menu,         ShiftMask,                      "\033[103;2u", 0,  0},
+	{ XK_Delete,       XK_NO_MOD,                      "\033[P",     -1,  0},
+	{ XK_Delete,       XK_NO_MOD,                      "\033[3~",    +1,  0},
+	{ XK_Delete,       ControlMask|ShiftMask,          "\033[255;6u", 0,  0},
+	{ XK_Delete,       Mod1Mask,                       "\033[255;3u", 0,  0},
+	{ XK_Delete,       Mod1Mask|ControlMask,           "\033[255;7u", 0,  0},
+	{ XK_Delete,       Mod1Mask|ControlMask|ShiftMask, "\033[255;8u", 0,  0},
+	{ XK_Delete,       Mod1Mask|ShiftMask,             "\033[255;4u", 0,  0},
+	{ XK_i,            ControlMask,                    "\033[105;5u", 0,  0},
+	{ XK_i,            Mod1Mask|ControlMask,           "\033[105;7u", 0,  0},
+	{ XK_m,            ControlMask,                    "\033[109;5u", 0,  0},
+	{ XK_m,            Mod1Mask|ControlMask,           "\033[109;7u", 0,  0},
+	{ XK_space,        ControlMask|ShiftMask,          "\033[32;6u",  0,  0},
+	{ XK_space,        Mod1Mask,                       "\033[32;3u",  0,  0},
+	{ XK_space,        Mod1Mask|ControlMask,           "\033[32;7u",  0,  0},
+	{ XK_space,        Mod1Mask|ControlMask|ShiftMask, "\033[32;8u",  0,  0},
+	{ XK_space,        Mod1Mask|ShiftMask,             "\033[32;4u",  0,  0},
+	{ XK_space,        ShiftMask,                      "\033[32;2u",  0,  0},
+	{ XK_0,            ControlMask,                    "\033[48;5u",  0,  0},
+	{ XK_A,            ControlMask|ShiftMask,          "\033[65;6u",  0,  0},
+	{ XK_B,            ControlMask|ShiftMask,          "\033[66;6u",  0,  0},
+	{ XK_C,            ControlMask|ShiftMask,          "\033[67;6u",  0,  0},
+	{ XK_D,            ControlMask|ShiftMask,          "\033[68;6u",  0,  0},
+	{ XK_E,            ControlMask|ShiftMask,          "\033[69;6u",  0,  0},
+	{ XK_F,            ControlMask|ShiftMask,          "\033[70;6u",  0,  0},
+	{ XK_G,            ControlMask|ShiftMask,          "\033[71;6u",  0,  0},
+	{ XK_H,            ControlMask|ShiftMask,          "\033[72;6u",  0,  0},
+	{ XK_I,            ControlMask|ShiftMask,          "\033[73;6u",  0,  0},
+	{ XK_I,            Mod1Mask|ControlMask|ShiftMask, "\033[73;8u",  0,  0},
+	{ XK_J,            ControlMask|ShiftMask,          "\033[75;6u",  0,  0},
+	{ XK_K,            ControlMask|ShiftMask,          "\033[74;6u",  0,  0},
+	{ XK_L,            ControlMask|ShiftMask,          "\033[76;6u",  0,  0},
+	{ XK_M,            ControlMask|ShiftMask,          "\033[77;6u",  0,  0},
+	{ XK_M,            Mod1Mask|ControlMask|ShiftMask, "\033[77;8u",  0,  0},
+	{ XK_N,            ControlMask|ShiftMask,          "\033[78;6u",  0,  0},
+	{ XK_O,            ControlMask|ShiftMask,          "\033[79;6u",  0,  0},
+	{ XK_P,            ControlMask|ShiftMask,          "\033[80;6u",  0,  0},
+	{ XK_Q,            ControlMask|ShiftMask,          "\033[81;6u",  0,  0},
+	{ XK_R,            ControlMask|ShiftMask,          "\033[82;6u",  0,  0},
+	{ XK_S,            ControlMask|ShiftMask,          "\033[83;6u",  0,  0},
+	{ XK_T,            ControlMask|ShiftMask,          "\033[84;6u",  0,  0},
+	{ XK_U,            ControlMask|ShiftMask,          "\033[85;6u",  0,  0},
+	{ XK_V,            ControlMask|ShiftMask,          "\033[86;6u",  0,  0},
+	{ XK_W,            ControlMask|ShiftMask,          "\033[87;6u",  0,  0},
+	{ XK_X,            ControlMask|ShiftMask,          "\033[88;6u",  0,  0},
+	{ XK_Y,            ControlMask|ShiftMask,          "\033[89;6u",  0,  0},
+	{ XK_Z,            ControlMask|ShiftMask,          "\033[90;6u",  0,  0},
+	{ XK_Z,            ControlMask|ShiftMask,          "\033[90;6u",  0,  0},
+	{ XK_0,            Mod1Mask|ControlMask,           "\033[48;7u",  0,  0},
+	{ XK_1,            ControlMask,                    "\033[49;5u",  0,  0},
+	{ XK_1,            Mod1Mask|ControlMask,           "\033[49;7u",  0,  0},
+	{ XK_2,            ControlMask,                    "\033[50;5u",  0,  0},
+	{ XK_2,            Mod1Mask|ControlMask,           "\033[50;7u",  0,  0},
+	{ XK_3,            ControlMask,                    "\033[51;5u",  0,  0},
+	{ XK_3,            Mod1Mask|ControlMask,           "\033[51;7u",  0,  0},
+	{ XK_4,            ControlMask,                    "\033[52;5u",  0,  0},
+	{ XK_4,            Mod1Mask|ControlMask,           "\033[52;7u",  0,  0},
+	{ XK_5,            ControlMask,                    "\033[53;5u",  0,  0},
+	{ XK_5,            Mod1Mask|ControlMask,           "\033[53;7u",  0,  0},
+	{ XK_6,            ControlMask,                    "\033[54;5u",  0,  0},
+	{ XK_6,            Mod1Mask|ControlMask,           "\033[54;7u",  0,  0},
+	{ XK_7,            ControlMask,                    "\033[55;5u",  0,  0},
+	{ XK_7,            Mod1Mask|ControlMask,           "\033[55;7u",  0,  0},
+	{ XK_8,            ControlMask,                    "\033[56;5u",  0,  0},
+	{ XK_8,            Mod1Mask|ControlMask,           "\033[56;7u",  0,  0},
+	{ XK_9,            ControlMask,                    "\033[57;5u",  0,  0},
+	{ XK_9,            Mod1Mask|ControlMask,           "\033[57;7u",  0,  0},
+	{ XK_ampersand,    ControlMask,                    "\033[38;5u",  0,  0},
+	{ XK_ampersand,    ControlMask|ShiftMask,          "\033[38;6u",  0,  0},
+	{ XK_ampersand,    Mod1Mask,                       "\033[38;3u",  0,  0},
+	{ XK_ampersand,    Mod1Mask|ControlMask,           "\033[38;7u",  0,  0},
+	{ XK_ampersand,    Mod1Mask|ControlMask|ShiftMask, "\033[38;8u",  0,  0},
+	{ XK_ampersand,    Mod1Mask|ShiftMask,             "\033[38;4u",  0,  0},
+	{ XK_apostrophe,   ControlMask,                    "\033[39;5u",  0,  0},
+	{ XK_apostrophe,   ControlMask|ShiftMask,          "\033[39;6u",  0,  0},
+	{ XK_apostrophe,   Mod1Mask,                       "\033[39;3u",  0,  0},
+	{ XK_apostrophe,   Mod1Mask|ControlMask,           "\033[39;7u",  0,  0},
+	{ XK_apostrophe,   Mod1Mask|ControlMask|ShiftMask, "\033[39;8u",  0,  0},
+	{ XK_apostrophe,   Mod1Mask|ShiftMask,             "\033[39;4u",  0,  0},
+	{ XK_asciicircum,  ControlMask,                    "\033[94;5u",  0,  0},
+	{ XK_asciicircum,  ControlMask|ShiftMask,          "\033[94;6u",  0,  0},
+	{ XK_asciicircum,  Mod1Mask,                       "\033[94;3u",  0,  0},
+	{ XK_asciicircum,  Mod1Mask|ControlMask,           "\033[94;7u",  0,  0},
+	{ XK_asciicircum,  Mod1Mask|ControlMask|ShiftMask, "\033[94;8u",  0,  0},
+	{ XK_asciicircum,  Mod1Mask|ShiftMask,             "\033[94;4u",  0,  0},
+	{ XK_asciitilde,   ControlMask,                    "\033[126;5u", 0,  0},
+	{ XK_asciitilde,   ControlMask|ShiftMask,          "\033[126;6u", 0,  0},
+	{ XK_asciitilde,   Mod1Mask,                       "\033[126;3u", 0,  0},
+	{ XK_asciitilde,   Mod1Mask|ControlMask,           "\033[126;7u", 0,  0},
+	{ XK_asciitilde,   Mod1Mask|ControlMask|ShiftMask, "\033[126;8u", 0,  0},
+	{ XK_asciitilde,   Mod1Mask|ShiftMask,             "\033[126;4u", 0,  0},
+	{ XK_asterisk,     ControlMask,                    "\033[42;5u",  0,  0},
+	{ XK_asterisk,     ControlMask|ShiftMask,          "\033[42;6u",  0,  0},
+	{ XK_asterisk,     Mod1Mask,                       "\033[42;3u",  0,  0},
+	{ XK_asterisk,     Mod1Mask|ControlMask,           "\033[42;7u",  0,  0},
+	{ XK_asterisk,     Mod1Mask|ControlMask|ShiftMask, "\033[42;8u",  0,  0},
+	{ XK_asterisk,     Mod1Mask|ShiftMask,             "\033[42;4u",  0,  0},
+	{ XK_at,           ControlMask,                    "\033[64;5u",  0,  0},
+	{ XK_at,           ControlMask|ShiftMask,          "\033[64;6u",  0,  0},
+	{ XK_at,           Mod1Mask,                       "\033[64;3u",  0,  0},
+	{ XK_at,           Mod1Mask|ControlMask,           "\033[64;7u",  0,  0},
+	{ XK_at,           Mod1Mask|ControlMask|ShiftMask, "\033[64;8u",  0,  0},
+	{ XK_at,           Mod1Mask|ShiftMask,             "\033[64;4u",  0,  0},
+	{ XK_backslash,    ControlMask,                    "\033[92;5u",  0,  0},
+	{ XK_backslash,    ControlMask|ShiftMask,          "\033[92;6u",  0,  0},
+	{ XK_backslash,    Mod1Mask,                       "\033[92;3u",  0,  0},
+	{ XK_backslash,    Mod1Mask|ControlMask,           "\033[92;7u",  0,  0},
+	{ XK_backslash,    Mod1Mask|ControlMask|ShiftMask, "\033[92;8u",  0,  0},
+	{ XK_backslash,    Mod1Mask|ShiftMask,             "\033[92;4u",  0,  0},
+	{ XK_bar,          ControlMask,                    "\033[124;5u", 0,  0},
+	{ XK_bar,          ControlMask|ShiftMask,          "\033[124;6u", 0,  0},
+	{ XK_bar,          Mod1Mask,                       "\033[124;3u", 0,  0},
+	{ XK_bar,          Mod1Mask|ControlMask,           "\033[124;7u", 0,  0},
+	{ XK_bar,          Mod1Mask|ControlMask|ShiftMask, "\033[124;8u", 0,  0},
+	{ XK_bar,          Mod1Mask|ShiftMask,             "\033[124;4u", 0,  0},
+	{ XK_braceleft,    ControlMask,                    "\033[123;5u", 0,  0},
+	{ XK_braceleft,    ControlMask|ShiftMask,          "\033[123;6u", 0,  0},
+	{ XK_braceleft,    Mod1Mask,                       "\033[123;3u", 0,  0},
+	{ XK_braceleft,    Mod1Mask|ControlMask,           "\033[123;7u", 0,  0},
+	{ XK_braceleft,    Mod1Mask|ControlMask|ShiftMask, "\033[123;8u", 0,  0},
+	{ XK_braceleft,    Mod1Mask|ShiftMask,             "\033[123;4u", 0,  0},
+	{ XK_braceright,   ControlMask,                    "\033[125;5u", 0,  0},
+	{ XK_braceright,   ControlMask|ShiftMask,          "\033[125;6u", 0,  0},
+	{ XK_braceright,   Mod1Mask,                       "\033[125;3u", 0,  0},
+	{ XK_braceright,   Mod1Mask|ControlMask,           "\033[125;7u", 0,  0},
+	{ XK_braceright,   Mod1Mask|ControlMask|ShiftMask, "\033[125;8u", 0,  0},
+	{ XK_braceright,   Mod1Mask|ShiftMask,             "\033[125;4u", 0,  0},
+	{ XK_bracketleft,  ControlMask,                    "\033[91;5u",  0,  0},
+	{ XK_bracketleft,  ControlMask|ShiftMask,          "\033[91;6u",  0,  0},
+	{ XK_bracketleft,  Mod1Mask,                       "\033[91;3u",  0,  0},
+	{ XK_bracketleft,  Mod1Mask|ControlMask,           "\033[91;7u",  0,  0},
+	{ XK_bracketleft,  Mod1Mask|ControlMask|ShiftMask, "\033[91;8u",  0,  0},
+	{ XK_bracketleft,  Mod1Mask|ShiftMask,             "\033[91;4u",  0,  0},
+	{ XK_bracketright, ControlMask,                    "\033[93;5u",  0,  0},
+	{ XK_bracketright, ControlMask|ShiftMask,          "\033[93;6u",  0,  0},
+	{ XK_bracketright, Mod1Mask,                       "\033[93;3u",  0,  0},
+	{ XK_bracketright, Mod1Mask|ControlMask,           "\033[93;7u",  0,  0},
+	{ XK_bracketright, Mod1Mask|ControlMask|ShiftMask, "\033[93;8u",  0,  0},
+	{ XK_bracketright, Mod1Mask|ShiftMask,             "\033[93;4u",  0,  0},
+	{ XK_colon,        ControlMask,                    "\033[58;5u",  0,  0},
+	{ XK_colon,        ControlMask|ShiftMask,          "\033[58;6u",  0,  0},
+	{ XK_colon,        Mod1Mask,                       "\033[58;3u",  0,  0},
+	{ XK_colon,        Mod1Mask|ControlMask,           "\033[58;7u",  0,  0},
+	{ XK_colon,        Mod1Mask|ControlMask|ShiftMask, "\033[58;8u",  0,  0},
+	{ XK_colon,        Mod1Mask|ShiftMask,             "\033[58;4u",  0,  0},
+	{ XK_comma,        ControlMask,                    "\033[44;5u",  0,  0},
+	{ XK_comma,        ControlMask|ShiftMask,          "\033[44;6u",  0,  0},
+	{ XK_comma,        Mod1Mask,                       "\033[44;3u",  0,  0},
+	{ XK_comma,        Mod1Mask|ControlMask,           "\033[44;7u",  0,  0},
+	{ XK_comma,        Mod1Mask|ControlMask|ShiftMask, "\033[44;8u",  0,  0},
+	{ XK_comma,        Mod1Mask|ShiftMask,             "\033[44;4u",  0,  0},
+	{ XK_dollar,       ControlMask,                    "\033[36;5u",  0,  0},
+	{ XK_dollar,       ControlMask|ShiftMask,          "\033[36;6u",  0,  0},
+	{ XK_dollar,       Mod1Mask,                       "\033[36;3u",  0,  0},
+	{ XK_dollar,       Mod1Mask|ControlMask,           "\033[36;7u",  0,  0},
+	{ XK_dollar,       Mod1Mask|ControlMask|ShiftMask, "\033[36;8u",  0,  0},
+	{ XK_dollar,       Mod1Mask|ShiftMask,             "\033[36;4u",  0,  0},
+	{ XK_equal,        ControlMask,                    "\033[61;5u",  0,  0},
+	{ XK_equal,        ControlMask|ShiftMask,          "\033[61;6u",  0,  0},
+	{ XK_equal,        Mod1Mask,                       "\033[61;3u",  0,  0},
+	{ XK_equal,        Mod1Mask|ControlMask,           "\033[61;7u",  0,  0},
+	{ XK_equal,        Mod1Mask|ControlMask|ShiftMask, "\033[61;8u",  0,  0},
+	{ XK_equal,        Mod1Mask|ShiftMask,             "\033[61;4u",  0,  0},
+	{ XK_exclam,       ControlMask,                    "\033[33;5u",  0,  0},
+	{ XK_exclam,       ControlMask|ShiftMask,          "\033[33;6u",  0,  0},
+	{ XK_exclam,       Mod1Mask,                       "\033[33;3u",  0,  0},
+	{ XK_exclam,       Mod1Mask|ControlMask,           "\033[33;7u",  0,  0},
+	{ XK_exclam,       Mod1Mask|ControlMask|ShiftMask, "\033[33;8u",  0,  0},
+	{ XK_exclam,       Mod1Mask|ShiftMask,             "\033[33;4u",  0,  0},
+	{ XK_grave,        ControlMask,                    "\033[96;5u",  0,  0},
+	{ XK_grave,        ControlMask|ShiftMask,          "\033[96;6u",  0,  0},
+	{ XK_grave,        Mod1Mask,                       "\033[96;3u",  0,  0},
+	{ XK_grave,        Mod1Mask|ControlMask,           "\033[96;7u",  0,  0},
+	{ XK_grave,        Mod1Mask|ControlMask|ShiftMask, "\033[96;8u",  0,  0},
+	{ XK_grave,        Mod1Mask|ShiftMask,             "\033[96;4u",  0,  0},
+	{ XK_greater,      ControlMask,                    "\033[62;5u",  0,  0},
+	{ XK_greater,      ControlMask|ShiftMask,          "\033[62;6u",  0,  0},
+	{ XK_greater,      Mod1Mask,                       "\033[62;3u",  0,  0},
+	{ XK_greater,      Mod1Mask|ControlMask,           "\033[62;7u",  0,  0},
+	{ XK_greater,      Mod1Mask|ControlMask|ShiftMask, "\033[62;8u",  0,  0},
+	{ XK_greater,      Mod1Mask|ShiftMask,             "\033[62;4u",  0,  0},
+	{ XK_less,         ControlMask,                    "\033[60;5u",  0,  0},
+	{ XK_less,         ControlMask|ShiftMask,          "\033[60;6u",  0,  0},
+	{ XK_less,         Mod1Mask,                       "\033[60;3u",  0,  0},
+	{ XK_less,         Mod1Mask|ControlMask,           "\033[60;7u",  0,  0},
+	{ XK_less,         Mod1Mask|ControlMask|ShiftMask, "\033[60;8u",  0,  0},
+	{ XK_less,         Mod1Mask|ShiftMask,             "\033[60;4u",  0,  0},
+	{ XK_minus,        ControlMask,                    "\033[45;5u",  0,  0},
+	{ XK_minus,        ControlMask|ShiftMask,          "\033[45;6u",  0,  0},
+	{ XK_minus,        Mod1Mask,                       "\033[45;3u",  0,  0},
+	{ XK_minus,        Mod1Mask|ControlMask,           "\033[45;7u",  0,  0},
+	{ XK_minus,        Mod1Mask|ControlMask|ShiftMask, "\033[45;8u",  0,  0},
+	{ XK_minus,        Mod1Mask|ShiftMask,             "\033[45;4u",  0,  0},
+	{ XK_numbersign,   ControlMask,                    "\033[35;5u",  0,  0},
+	{ XK_numbersign,   ControlMask|ShiftMask,          "\033[35;6u",  0,  0},
+	{ XK_numbersign,   Mod1Mask,                       "\033[35;3u",  0,  0},
+	{ XK_numbersign,   Mod1Mask|ControlMask,           "\033[35;7u",  0,  0},
+	{ XK_numbersign,   Mod1Mask|ControlMask|ShiftMask, "\033[35;8u",  0,  0},
+	{ XK_numbersign,   Mod1Mask|ShiftMask,             "\033[35;4u",  0,  0},
+	{ XK_parenleft,    ControlMask,                    "\033[40;5u",  0,  0},
+	{ XK_parenleft,    ControlMask|ShiftMask,          "\033[40;6u",  0,  0},
+	{ XK_parenleft,    Mod1Mask,                       "\033[40;3u",  0,  0},
+	{ XK_parenleft,    Mod1Mask|ControlMask,           "\033[40;7u",  0,  0},
+	{ XK_parenleft,    Mod1Mask|ControlMask|ShiftMask, "\033[40;8u",  0,  0},
+	{ XK_parenleft,    Mod1Mask|ShiftMask,             "\033[40;4u",  0,  0},
+	{ XK_parenright,   ControlMask,                    "\033[41;5u",  0,  0},
+	{ XK_parenright,   ControlMask|ShiftMask,          "\033[41;6u",  0,  0},
+	{ XK_parenright,   Mod1Mask,                       "\033[41;3u",  0,  0},
+	{ XK_parenright,   Mod1Mask|ControlMask,           "\033[41;7u",  0,  0},
+	{ XK_parenright,   Mod1Mask|ControlMask|ShiftMask, "\033[41;8u",  0,  0},
+	{ XK_parenright,   Mod1Mask|ShiftMask,             "\033[41;4u",  0,  0},
+	{ XK_percent,      ControlMask,                    "\033[37;5u",  0,  0},
+	{ XK_percent,      ControlMask|ShiftMask,          "\033[37;6u",  0,  0},
+	{ XK_percent,      Mod1Mask,                       "\033[37;3u",  0,  0},
+	{ XK_percent,      Mod1Mask|ControlMask,           "\033[37;7u",  0,  0},
+	{ XK_percent,      Mod1Mask|ControlMask|ShiftMask, "\033[37;8u",  0,  0},
+	{ XK_percent,      Mod1Mask|ShiftMask,             "\033[37;4u",  0,  0},
+	{ XK_period,       ControlMask,                    "\033[46;5u",  0,  0},
+	{ XK_period,       ControlMask|ShiftMask,          "\033[46;6u",  0,  0},
+	{ XK_period,       Mod1Mask|ControlMask,           "\033[46;7u",  0,  0},
+	{ XK_period,       Mod1Mask|ControlMask|ShiftMask, "\033[46;8u",  0,  0},
+	{ XK_period,       Mod1Mask|ShiftMask,             "\033[46;4u",  0,  0},
+	{ XK_plus,         ControlMask,                    "\033[43;5u",  0,  0},
+	{ XK_plus,         ControlMask|ShiftMask,          "\033[43;6u",  0,  0},
+	{ XK_plus,         Mod1Mask,                       "\033[43;3u",  0,  0},
+	{ XK_plus,         Mod1Mask|ControlMask,           "\033[43;7u",  0,  0},
+	{ XK_plus,         Mod1Mask|ControlMask|ShiftMask, "\033[43;8u",  0,  0},
+	{ XK_plus,         Mod1Mask|ShiftMask,             "\033[43;4u",  0,  0},
+	{ XK_question,     ControlMask,                    "\033[63;5u",  0,  0},
+	{ XK_question,     ControlMask|ShiftMask,          "\033[63;6u",  0,  0},
+	{ XK_question,     Mod1Mask,                       "\033[63;3u",  0,  0},
+	{ XK_question,     Mod1Mask|ControlMask,           "\033[63;7u",  0,  0},
+	{ XK_question,     Mod1Mask|ControlMask|ShiftMask, "\033[63;8u",  0,  0},
+	{ XK_question,     Mod1Mask|ShiftMask,             "\033[63;4u",  0,  0},
+	{ XK_quotedbl,     ControlMask,                    "\033[34;5u",  0,  0},
+	{ XK_quotedbl,     ControlMask|ShiftMask,          "\033[34;6u",  0,  0},
+	{ XK_quotedbl,     Mod1Mask,                       "\033[34;3u",  0,  0},
+	{ XK_quotedbl,     Mod1Mask|ControlMask,           "\033[34;7u",  0,  0},
+	{ XK_quotedbl,     Mod1Mask|ControlMask|ShiftMask, "\033[34;8u",  0,  0},
+	{ XK_quotedbl,     Mod1Mask|ShiftMask,             "\033[34;4u",  0,  0},
+	{ XK_semicolon,    ControlMask,                    "\033[59;5u",  0,  0},
+	{ XK_semicolon,    ControlMask|ShiftMask,          "\033[59;6u",  0,  0},
+	{ XK_semicolon,    Mod1Mask,                       "\033[59;3u",  0,  0},
+	{ XK_semicolon,    Mod1Mask|ControlMask|ShiftMask, "\033[59;8u",  0,  0},
+	{ XK_semicolon,    Mod1Mask|ControlMask,           "\033[59;7u",  0,  0},
+	{ XK_semicolon,    Mod1Mask|ShiftMask,             "\033[59;4u",  0,  0},
+	{ XK_slash,        ControlMask|ShiftMask,          "\033[47;6u",  0,  0},
+	{ XK_slash,        Mod1Mask,                       "\033[47;3u",  0,  0},
+	{ XK_slash,        Mod1Mask|ControlMask,           "\033[47;7u",  0,  0},
+	{ XK_slash,        Mod1Mask|ControlMask|ShiftMask, "\033[47;8u",  0,  0},
+	{ XK_slash,        Mod1Mask|ShiftMask,             "\033[47;4u",  0,  0},
+	{ XK_underscore,   ControlMask,                    "\033[95;5u",  0,  0},
+	{ XK_underscore,   ControlMask|ShiftMask,          "\033[95;6u",  0,  0},
+	{ XK_underscore,   Mod1Mask,                       "\033[95;3u",  0,  0},
+	{ XK_underscore,   Mod1Mask|ControlMask,           "\033[95;7u",  0,  0},
+	{ XK_underscore,   Mod1Mask|ControlMask|ShiftMask, "\033[95;8u",  0,  0},
+	{ XK_underscore,   Mod1Mask|ShiftMask,             "\033[95;4u",  0,  0},
 };
 
 /*
-- 
2.44.0

